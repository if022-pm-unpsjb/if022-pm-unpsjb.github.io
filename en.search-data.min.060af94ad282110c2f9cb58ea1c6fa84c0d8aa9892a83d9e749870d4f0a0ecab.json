[{"id":0,"href":"/docs/01-introduccion/","title":"Introducción a los Sistemas Distribuidos","section":"Docs","content":" Introducción # the #1 rule of distribute computing: Don’t distribute your computing! At least if you can in any way avoid it\nYou\u0026rsquo;re not Google. Your company will never be Google\u0026hellip; Is there a reason we can\u0026rsquo;t just do this all in Postgres?\nAvances imporantes han ocurrido en las últimas décadas:\nDesarrollo de microprocesadores potentes, pequeños y ecónomicos. Avance de las tecnologías de comunicaciones. Miniaturización de los sistemas de cómputo (ES, IoT, SoCs, etc). En la actualidad es relativamente sencillo desarrollar un sistema compuesto de múltiples computadoras conectadas por una red. Al estar las computadoras físicamente separadas se habla de un sistema distribuido.\nDefinición # You know you have a distributed system when the crash of a computer you have never heard of stops you from getting any work done. \u0026ndash; Leslie Lamport\nUna colección de elementos computacionales autónomos que dan la apariencia a sus usuarios de ser un sistema coherente \u0026ndash; Tanenbaum y Van Steen.\nAunque no existe una definición que sea ampliamente aceptada por toda la disciplina, la distribución de los componentes en diferentes sistemas comunicados mediante una red es una característica común.\nCaracteristica 1: elementos independientes # Nodos independientes que colaboran para alcanzar un objetivo común. Los nodos son heterogéneos. La comunicación entre los nodos se realiza mediante paso de mensajes. No se existe un reloj global (dificulta la sincronización y coordinación). La concurrencia y el paralelismo es natural. Organizado como una red superpuesta, estructurada o no-estructurada (ej: sistemas p2p). Fallas parciales (independientes). Se tiene que resolver cuestiones de organización y membresía (grupos cerrados, abiertos). Caracteristica 2: sistema coherente # El sistema se comporta de acuerdo a las expectativas de sus usuarios. Transparencia de distribución: no importa como, cuando ni donde se conecte al sistema, el usuario debe tener el mismos servicio. Sin embargo, no es posible (ni deseable) ocultar todos los detalles de la distribución del sistema. Fundamental poder lidiar con fallas parciales. Distribuido vs Descentralizado # Conceptos relacionados\nSistema distribuido: componentes colaboran para realizar una tarea o proveer un servicio.\nSistema descentralizado: componentes con mayor autonomía sin único punto de control.\nUn sistema distribuido puede estar logicamente centralizado: DNS.\nUn sistema descentralizado no tiene una autoridad central: blockchain (ej. Bitcoin)\nOtra vision es la siguiente:\nSistema integrativo (conectar sistemas existentes formando así uno nuevo) Sistema expansivo (agregar nodos a un sistema existente). Luego:\nSistema descentralizado: visión integrativa, los recursos se encuentran necesariamente dispersos. Sistema distribuido: visión expansiva, los recursos se encuentran suficientemente dispersos. Complejidad # Los sistemas distribuidos son inherentemente complejos. Los sistemas centralizados son más sencillos. La distribución no es un fin en sí mismo: considerar soluciones lo más simples posibles. Middleware # Los componentes y funciones comunmente usados en un sistema distribuido se agrupan en un middleware, una capa de software entre el sistema operativo y las aplicaciones que intenta abstraer los detalles escabrosos y ofrecer una interfaz más amigable.\nPor ejemplo, un middleware ofrece:\nComunicación (RPC, RMI, paso de mensajes, etc.) Manejo de transacciones. Composición de servicios. Confiabilidad. Objetivos de diseño # Sólo por que sea posible no quiere decir que diseñar un sistema distribuido sea siempre una buena idea.\nUn sistema distribuido debe poder satisfacer alguno de los siguientes objetivos, para que su implementación valga la pena:\nPermitir que los recursos sean más fácilmente accesibles. Ocultar en lo posible que los recursos están desperdigados (transparencia de distribución). Debe ser abierto. Debe poder ser escalable. Compartir recursos # Por cuestiones económicas. Mejorar la colaboración. Ejemplo clásico: p2p Transparencia de distribución # Un sistema distribuido debe (en lo posible) ocultar que los procesos y recursos estan fisicamente distribuidos: esto se conoce como transparencia de distribución.\nDiversos tipos:\nAcceso: ocultar cómo se accede al recurso y la representación de datos. Ubicación: ocultar la ubicación de un recurso. Reubicación: ocultar el hecho de que el recurso pueda cambiar su ubicación mientras esta en uso. Migración: ocultar el hecho de que un recurso cambie su ubicación. Replicación: ocultar el hecho de que existan múltiples copias de un mismo recurso. Concurrencia: ocultar el hecho de que un recurso pueda ser accedido por múltiples usuarios. Falla: ocultar la falla y recuperación de un recurso u objeto. No siempre es deseable o posible alcanzar el máximo grado de transparencia.\nEs imposible ocultar las latencias de una red WAN u ocultar la falla de un nodo. Compromiso entre el nivel de transparencia y perfomance: Mantener las replicas consistentes incurre en un costo temporal que no se puede ocultar. Se puede argumentar que es mejor exponer la distribución al usuario, en lugar de ocultarla. Abierto # Poder interactuar con otros sistemas. Requiere interfaces bien definidas.\nUn sistema abierto es aquel que permite que sus componentes sean utilizados en otros sistemas. También generalmente un sistema abierto esta compuesto por componentes de otros sistemas. Beneficia la interoperabilidad, portabilidad, composibility y extensibilidad. Una característica importante para lograr este objetivo es la de separar política de mecanismo, evitando soluciones monolíticas.\nEscalabilidad # La escalabilidad abarca tres dimensiones:\nTamaño: la facilidad con que se pueden sumar usuarios o recursos.\nGeneralmente relacionado con limites en capacidad de cómputo, almacenamiento y ancho de banda. Pueden ser formalmente analizados mediante teoría de colas. Geografía: los recursos y usuarios pueden estar desperdigados pero las latencias no afectan seriamente al sistema.\nEl principal problema es la comunicación sincrónica sobre enlaces con alta latencia. Las WANs ofrecen menor confiabilidad que una LAN, menor capacidad de ancho de banda. ¿Multicast / Broadcast? Posible en LANs, no tan así en WANs. Administrativa: el sistema abarca distintas unidades organizacionales pero aún así es fácilmente administrable.\nCómo resolver conflictos de políticas acerca de uso, pago, administración, seguridad, etc. Ejemplos:\nTamaño: incrementar fácilmente el número de usuarios o procesos. Geografía: poder aumentar la distancia entre nodos. Administrativo: integrar recursos de otra organización. Soluciones:\nEscalar verticalmente: simplemente incrementar la capacidad del servicio (computo, almacenamiento o ancho de banda). Escalar horizontalmente: Ocultar latencias: comunicación asíncrona, fat-clients, etc. Distribuir el trabajo: dividir un componente y dispersarlo por el sistema. Ej: mover computo al cliente (Java Applet), descentralizar un servicio (DNS), descentralizar contenido (WWW), etc. Replicar: contar con una copia cercana, cache, etc. Problemas de consistencia. Consistencia estricta requiere sincronización global (costoso, reduce escalabilidad). Tipos de sistemas distribuidos # A grandes rasgos, podemos clasificar los sistemas distribuidos en sistemas distribuidos de cómputo, de información y pervasivos.\nCómputo: Cluster: conjunto de sistemas interconectados por una red de alta velocidad. Grid: nodos dispersos, heterogéneos, diferentes organizaciones. Cloud: software/infraestructura como servicio. Edge Información: Integración de sistemas de información ya existentes; ofrecer servicios como transacciones distribuidas. Pervasiva: Sistemas móviles, embebidos, IoT. No existe una topología estática, ni conexión permanente, etc. Tres tipos: ubicuos, móviles y redes de sensores (los límites entre la categorías son difusos). Falacias # Desarrollar un (buen) sistema distribuido es una tarea ardua. Las siguientes falsas presunciones durante el diseño del sistema, traen como consecuencia complejidad innecesaria y errores:\nLa red es confiable. La red es segura. La red es homogenea. La topología no cambia. La latencia es cero. El ancho de banda es infinito. El costo del transporte es cero. Sólo existe un administrador. Algunas más:\nUn sistema centralizado no escala: Un sistema físicamente centralizado quizá no, pero uno lógicamente centralizado sí (ejemplo DNS). Un sistema centralizado tiene un unico punto de falla: Si, pero un solo punto de falla es más fácil de administrar, más fácil de arreglar. Soluciones: en el caso de DNS, cada root server es a su vez un cluster. ¿Que vamos a estudiar? # Arquitectura: ¿Como organizar el sistema? Procesos: ¿Procesos, hilos? Comunicacion: ¿Como comunicar entre los nodos? Coordinación: ¿Cómo coordinar acciones? ¿Y cómo hacerlo de una manera independiente de la aplicación? Nombres: ¿Cómo identificar los diferentes recursos? Consistencia y replicación: Si se replica, ¿como se maneja la consistencia? Tolerancia a fallas: como mantener el sistema funcionando ante la falla de un componente. Seguridad: asegurar acceso autorizado a los recursos. "},{"id":1,"href":"/docs/02-arquitectura/","title":"Arquitecturas","section":"Docs","content":" Arquitecturas # Es fundamental una correcta organización para administrar la complejidad de un sistema distribuido.\nPodemos diferenciar:\nLa organización de los componentes de software (arquitectura de software). Cómo están físicamente instanciados (arquitectura del sistema). Estilo arquitectonico # Organización lógica de los componentes de software del sistema:\nComponentes. Unidad modular con interfaces bien definidas (reemplazable). Cómo se conectan y comunican. Conector: el mecanismo que media la comunicación entre los componentes. Qué datos intercambian. Cómo están configurados. Según como se configuran componentes y conectores, tenemos una arquitectura de software.\nArquitecturas tipicamente utilizadas en sistemas distribuidos son:\nArquitecturas por capas. Orientadas a los servicios. Publish-subscribe. Arquitectura por capas # Los componentes se organizan en capas. Un componente en la capa N invoca generalmente los servicios de un componente en la capa N-1. Excepcionalmente, un componente puede invocar un servicio de una capa superior (N+1).\nEjemplo clásico: protocolos de comunicación de redes (TCP/IP, OSI, etc).\nMuchas aplicaciones se organizan en capas siguiendo el siguiente estilo:\nCapa de presentación o interfaz de usuario. Capa de procesamiento o de negocio. Capa de datos o persistencia. Desventaja:\nExiste una dependencia fuerte entre las distintas capas. Orientadas a los servicios # Organización más imprecisa, donde cada componente encapsula un servicio. El sistema se estructura como una composición de servicios.\nOrientado a objetos (invocación de objetos remotos).\nMicroservicios (cada componente representa un servicio separado e independiente).\nBasada en recursos (REST).\nObjetos:\nCada componente corresponde con objeto. Se comunican mediante algún mecanismo de invocación. Encapsular datos y procedimientos dentro del objeto, ofreciendo una interface. Los objetos pueden estar distribuidos. Microservicios:\nMas info: https://microservices.io/ \u0026ldquo;same crap, but distributed\u0026rdquo; the biggest issue with microservices is that they convert nice errors with a stack trace to network errors SOA:\nLa aplicación es una composición de servicios. Estos pueden pertenecer a diferentes organizaciones administrativas. Ej: procesador de pagos. Basados en recursos:\nEn lugar de servicios, se consideran recursos. Popular por su simplicidad. Publish-subscribe # Separación de procesamiento y coordinación (comunicación y cooperación).\nEl sistema es visto como un conjunto de componentes autónomos.\nLograr que los componentes no tengan dependencias explicitas.\nLos componentes describen los eventos que le son de interés.\nEvent-based\nReferencialmente desacoplados Temporalmente acoplados Space-based\nReferencial y temporalmente desacoplados. Comunicación mediante tuplas Procesos ingresan tuplas en un espacio compartido. Recuperación mediante búsqueda Ambos tipos se pueden combinar (generar evento cuando tuplas de interés son ingresadas al espacio de intercambio)\nEn este caso, hablamos de publicación - subscripción.\n- Se deben describir los eventos de interes. - Generalmente como (atributo, valor) o (atributo, rango) El middleware # Facilita el desarrollo de un sistema distribuido. Es una capa que administra recursos y ofrece servicios comunes.\nEl principal objetivo es ayudar en la transparencia de distribución.\nPor ejemplo, se puede encargar de:\nAcceso a recursos remotos. Ofrecer servicios para la comunicación entre componentes. Servicios de seguridad y administración. Recuperación de fallas. Coordinación. Etc. Algunos ejemplos concretos en sistemas distribuidos:\nServicio de Mensajería: RabbitMQ, ZeroMQ, Llamadas a procedimientos remotos: RPC, RMI, gRPC Objetos distribuidos: CORBA Streaming de datos y eventos: Apache Kafka Monitores de transacciones distribuidas El middleware se puede organizar de varias maneras. Por ejemplo:\nWrappers: por aplicación o centralizado. Interceptores: Permite ejecutar código adicional durante la ejecución de un servicio. Arquitectura del sistema # Ubicación e interaccion de los componentes software junto con el hardware.\nPensar en clientes que piden servicios a servidores ayuda con la complejidad de los sistemas distribuidos.\nArquitectura en capas # Cliente-servidor:\nModelo más sencillo Procesos divididos en dos grupos: clientes que invocan un servicio implementado en servidores La invocacion puede usar una conexión no confiable (quiza usando operaciones idempotentes) o confiable (TCP, cuando la red no es fiable). No siempre se puede definir de manera precisa la separación entre cliente y servidor. Puede variar. Existen múltiples alternativas de como distribuir tres capas lógicas en un modelo cliente-servidor.\nDos capas (two-tier) Multicapa: distribuir las capas en múltiples máquinas, por ejemplo una arquitectura de 3-capas. Distribución vertical: componentes lógicos separados en máquinas separadas.\nArquitecturas simétricas # Distribución horizontal: dividir cada componente lógico (servidor, cliente).\npeer to peer (p2p): las funcionalidades del sistema están presentes en todos los procesos que constituyen el sistema. Un nodo puede actuar tanto como cliente o como servidor. La arquitectura del sistema toma la forma de una red sobrepuesta, que puede ser estructurada o no.\np2p estructurados # Los nodos se organizan según alguna topología concreta: anillo, árbol, matriz, etc. En general cada nodo es responsable de mantener un cierto conjunto de datos, identificados mediante un identificador (generalmente, una función hash de los datos). Así, la red p2p es básicamente un tabla hash distribuida. La topología define como debe realizarse el ruteo de una consulta al nodo correspondiente.\nEjemplo: chord\np2p no estructurados # No existe una topología predefinida y cada nodo mantiene una lista ad-hoc de nodos vecinos, lo que da como resultado un grafo aleatorio. Al momento de unirse, un nodo contacta un nodo bien conocido para obtener una lista inicial de vecinos. La búsqueda de datos requiere técnicas como inundación o random walks.\nInundación: se pasa la búsqueda a todos los nodos vecinos. Un nodo ignora una búsqueda que ya recibió. Puede responder al nodo que originó la búsqueda o al que se la reenvió. La búsqueda tiene un TTL asociado. TTL igual a 1 para buscar entre nodos vecinos.\nAleatorio: se pregunto a un nodo vecino al azar. Si no tiene el dato, este repite el procedimiento. Menor trafico, mayor tiempo de búsqueda. Se puede paralelizar y también tiene un TTL asociado.\nPor política: mantener una lista de nodos que han respondido peticiones, etc.\np2p jerárquicos # Para aliviar problemas de escalabilidad, un p2p no-estructurado puede tener nodos especiales que mantengan un índice de items o datos, conocidos como \u0026ldquo;super pares\u0026rdquo;.\nNodo \u0026ldquo;weak\u0026rdquo; se conecta a la red a travez de un super-par. Puede ser siempre el mismo o no. Para mejorar confiabilidad, puede requerirse conectarse a n \u0026gt; 1 superpares. Los nodos superpares se organizan en una red p2p propia (de ahí la jerarquía) Problemas: ¿Cómo elegir que nodo superpar utilizar? ¿Cómo elegir cuales seran superpares? Elección de lider. Ejemplo: bittorrent, CDN.\nArquitecturas híbridas # En la práctica, un sistema complejo abarca múltiples arquitecturas.\nCloud computing # Permite el acceso a un conjunto de recursos virtualizados de fácil acceso. Cúantos de estos recursos son necesarios y cómo serán usados, es definido dinámicamente: por ejemplo, si un cliente requiere más poder de cómputo, simplemente puede pedir procesador virtuales adicionales. Básicamente, una nube se organiza en cuatro capas:\nHardware: la capa más baja, que los clientes generalmente no ven, organizada en data-centers. Infraestructura: una capa de virtualización sobre los recursos de hardware, para ofrecerlos a los clientes. Plataforma: provee una capa de abstracción para la ejecución de aplicaciones y/o administración de recursos como almacenamiento. Aplicación: aplicaciones que pueden ser adaptadas por los clientes, como suites ofimáticas. Estas capas son accesibles mediante una multitud de interfaces (web-services, APIs, etc).\nA su vez, da lugar a tres capas de servicios diferenciados:\nIasS (Infraestructure-as-a-service) PaaS (Platform-as-a-service) SaaS (Software-as-a-service) FaaS (Function-as-a-service): ejemplo AWS Lambda. El uso de un servicio en la nube tiene similitudes con la arquitectura cliente-servidor. Sin embargo, el servidor es totalmente opaco al cliente: no se sabe donde ejecuta, como esta implementado, etc.\nEdge computing # Como colocar los recursos en el \u0026ldquo;límite\u0026rdquo; de la red, entre los dispositivos y la nube. Generalmente, en los ISPs. Complementa cloud para reducir la latencia y el uso de ancho de banda. También permite aumentar la confiabilidad, y puede ser necesario para cumplir con políticas de privacidad y seguridad. Aumenta la complejidad de la administración de la aplicación.\nEj: Akamai, Netflix CDN, IoT, etc.\nArgumentos a favor de edge computing:\nLatencia y ancho de banda: aunque el ancho de banda se ha incrementado en los últimos años, contar con los recursos más cerca del usuario final permite mejores garantías acerca del ancho de banda negociado. En cambio, la latencia es un problemas más complicado y donde existe un límite físico. En este caso, la cercanía reduce la latencia.\nConfiabilidad: Existen ciertos casos donde se debe garantizar el funcionamiento aún ante falta de conectividad a la nube.\nSeguridad y privacidad: por razones politicas/regulatorias ciertos datos no pueden ser subidos a la nube.\nDesafios en orquestación:\nRecursos: para garantizar la disponibilidad de recursos, ¿como deben ser asignados o provisionados?\nUbicación: Dónde y cúando los recursos deben ser hechos disponibles.\nSelección: no necesariamente el nodo más cercano es el mejor.\nBlockchain apps # Una presunción en el diseño de estas aplicaciones es que ningún nodo es confiable. Las transacciones son registras por un gran número de nodos participantes. Entre todos los nodos se mantiene una sola cadena de transacciones validadas. Dado que cada bloque es inmutable, la estructura de datos es fácilmente replicable.\nLa diferencia fundamental entre múltiples implementaciones es cuales nodos se encargan de realizar las validaciones (esto es, agregar nuevos bloques a la cadena). Agregar un bloque es básicamente llegar a un consenso entre los distintos nodos con rol de validador. Los tipos de consenso pueden ser:\nCentralizado: posible, pero en contra del diseño del sistema.\nDistribuido: un grupo preseleccionado de nodos se encarga de este rol.\nLos nodos llegan a un consenso, tolerando así participantes maliciosos. Si hay n nodos validadores, se toleran hasta k \u0026lt;= (n - 1)/3 nodos maliciosos/defectuosos. El problema es que en general n es un numero pequeño. Descentralizada: todos los nodos participantes llegan a un consenso.\nMediante consenso todos los nodos escogen un nodo que llevara adelante la validación. Este validación puede ser premiada. No todos los nodos desearan ser elegibles, principalmente por costo de la validación. "},{"id":2,"href":"/docs/03-procesos/","title":"Procesos","section":"Docs","content":" Procesos # Hilos, virtualización, cliente/servidor, migración.\nProcesos # Un proceso ofrece mejor isolación entre tareas.\nSobre todo, la protección puede ser asegurada por el hardware.\nHilos # Los hilos nos permiten mantener la idea de procesos secuenciales que se bloquean por E/S junto con concurrencia:\nUn mismo proceso puede tener multiples hilos, cada uno visto como un programa secuencial. Evita tener que lidiar con callbacks asincrónicos. El uso de hilos provee un mejor nivel de granularidad para el desarrollo de aplicaciones distribuidas y provee un mejor nivel de performance.\nA diferencia de los procesos, los hilos no ofrecen transparencia de concurrencia:\nComparten el mismo segmento de memoria. Mayor dificultad al diseñar la aplicación. Implementación:\nNivel de usuario: creación/destrucción y cambio de contexto menos costoso; bloqueo de todo el proceso. Nivel de kernel: administración y sincronización ligeramente más costosa, pero sin bloqueo de todo el proceso. En un sistema distribuido, el uso de hilos permite simplificar la comunicación entre nodos, al implementar esta funcionalidad en un hilo separado en el programa.\nEjemplo:\nUn cliente multi-hilo permite ocultar latencias, mejorando así la transparencia de distribución. Un navegador web permite visualizar una página aún cuando no se haya descargado completamente. La mayor ventaja se puede observar en la implementación de servidores concurrentes.\nAlternativas:\nun solo hilo (secuencial) uso de máquinas de estado (más complejo). Virtualización # El software por lo general \u0026ldquo;sobrevive\u0026rdquo; al hardware.\nMediante la virtualización es posible reemplazar una interface particular de un sistema (sea hardware o software) por otra implementación que copia exactamente su comportamiento.\n¿Por qué es utilizada?\nPermitir que software ejecute en nuevas arquitecturas. Simplifica el soporte de aplicaciones del lado del servidor: no requiere mantener multiples máquinas fisicas. Portabilidad y flexibilidad: migración de maquinas virtuales enteras de cloud a edge, por ejemplo. Seguridad: aislar codigo en ejecucion a un entorno virtual. Tipo de virtualización # Hardware: instrucciones hardware de la plataforma (privilegiadas y no-privilegiadas). Llamadas al sistema: ofrecidas por el sistema operativo. API: ofrecida por la aplicación/librería. Contenedores # Permitir que múltiples aplicaciones ejecuten de manera aislada, cada una con su propio ambiente de software (librerías, sistema operativo, etc).\nUso de maquinas virtuales en ssdd # En la computación en la nube, la virtualización es fundamental para ofrecer servicios IaaS (Infraestructure as-a service) Clientes # En un sistema distribuido, el software ejecutando en el cliente busca por lo general mejorar la transparencia de distrbución\nAcceso. Ubicación. Migración. Reubicación. Replicación. Falla. Concurrencia. Servidores # Un servidor implementa una serie de servicios que ejecuta a pedido de un cliente. El servidor espera por una petición, la procesa y retorna el resultado.\nEl servidor puede estar organizado como:\nIterativo Concurrente Los clientes se contactan con el servidor haciendo uso de un endpoint. Generalmente, una IP:PUERTO. Estos pueden ser bien conocidos o requerir un lookup previo por parte del cliente.\nSegún la información de estado que administre, un servidor puede ser:\nSin estado: la información del cliente se descarta cuando finaliza la conexión / operación. Con estado: mantiene información persistente de sus clientes. Servidor de objetos # El servidor no ofrece una funcionalidad específica, en cambio esta es provista por los objetos que almacena.\nCluster de servidores # Lan Cluster # Un conjunto de servidores interconectados por una red de alta velocidad.\nOrganización general:\nPrimer capa: switch que redirecciona las peticiones Segunda capa: conjunto de nodos que ejecutan la logica de negocio/servicio Tercer capa: nodos que se encargan de persistencia de datos La redirección de peticiones puede realizarse en\nnivel de transporte (ej TCP) nivel de aplicación (en base al contenido del request) Wan Cluster # Uso de DNS para el balanceo de carga o reducción de latencia. Ejemplo: Content Delivery Networks (CDNs) como Akamai Migración de código # Razones # Perfomance\nMover código/procesos a nodos con menor carga. Actualmente se busca mover procesos de nodos con poca carga a otros con carga media/alta. Estrategia de optimización de consumo de energía en datacenters. Migración de VMs menos compleja (aunque requiere más recursos) que migración de procesos. En un sistema distribuido puede importar más reducir latencias que mejorar perfomance de ejecución. La heterogenidad de plataformas dificulta determinar ganancia de computo. Seguridad y privacidad\nMover el código/procesos a donde esten los datos por cuestiones de seguridad/privacidad de los mismos. Por ejemplo, mover procesos para entrenar una red neuronal a los nodos con los datos, no al reves. Flexibilidad\nPermitir reconfigurar dinámicamente un sistema distribuido. Por ejemplo, descargar implementación de un protocolo dinámicamente para comunicación con un servidor. Modelos para migración de código # Ademas de código, puede ser necesario mover datos y el contexto de ejecución (migración de procesos) Podemos identificar en un proceso: código, recursos y contexto de ejecución. La migración se puede clasificar como sender-initiated: ej, enviar un programa a un servidor para su ejecución receiver-initiated: recepcionar un codigo, ejemplo un applet o javascript Como resultado, tenemos cuatro modelos: Cliente-Servidor: todo se ejecuta en el servidor, solo se envia un resultado. Evaluación Remota: código migra al servidor, donde se ejecuta. Codigo a demanda: código migra al cliente, donde se ejecuta. Agentes móbiles: se migra código y contexto de ejecución. Se puede diferenciar tambien: Movilidad débil: solo se migra código (requiere crear un nuevo ambiente de ejecución), modelo sencillo. Movilidad fuerte: se migra código y ambiente de ejecución (ej, migración de un proceso en ejecución, o clonado). Heterogeneidad # Los sistemas distribuidos son heterogéneos No siempre se puede migrar código y ejecutarlo en el nodo receptor, por diferencias en arquitectura, software, etc. Solución: interpretes y/o máquinas virtuales Ejemplos de lenguajes: Python, Java, Pascal, Erlang/Elixir, etc. Migración de todo el entorno: VMs como Dropbox, VMWare, VirtualPC, etc. "},{"id":3,"href":"/docs/04-comunicacion-rpc/","title":"Comunicación","section":"Docs","content":" Comunicación # Fundamental en un sistema distribuido. Las primitivas de comunicación que ofrece el sistema operativo pueden no tener el nivel de abstracción necesario.\nFundaciones # El modelo OSI # Modelo de siete capas, no utilizado en la práctica, pero que es una referencia útil acerca de como esta estructurado lógicamente el stack de comunicación.\nMiddleware # Los servicios middleware para un sistema distribuido estarían logicamente ubicados en las capas de sesión y presentación del modelo OSI, aunque también pueden incorporar servicios en la capa de aplicación.\nTipos de comunicación # El middleware puede ser visto como un servicio adicional que media en la comunicación en una arquitectura cliente/servidor.\nLos tipos de comunicación se pueden categorizar en:\nPersistente:\nEl mensaje es almacenado por el middleware todo el tiempo que sea necesario para realizar la entrega. El emisor no necesita esperar a que se complete la recepción. El receptor no tiene por que estar ejecutando al ser enviado el mensaje. Transitoria:\nEl mensaje es almacenado únicamente el tiempo suficiente para el envío, sólo si emisor y receptor estan ejecutando. Cualquier error descarta el mensaje. Asincrónica:\nEl emisor continua con la ejecución luego de envíar el mensaje, quiza sin confirmación de envío ni recepción. Sincrónica:\nEl emisor se bloquea hasa que el mensaje sea aceptado (envío, recepción, procesamiento). RPC # Los desarrolladores estan familiarizados con el paradigma procedural. Si un procedimiento esta diseñado de manera que funcione aislado, no hay impedimento en principio que pueda ejecutar en otra maquina.\nIdea básica de RPC: Permitir invocar funciones remotas como si fueran locales.\nIdea sencilla pero de implementación compleja. Contribuye a la transparencia de distribución, especialmente a la transparencia de acceso. Problemas: falta de un espacio de direcciones común, diferencia en arquitecturas, caída de alguno de los procesos que se comunican, etc.\nEl proceso cliente invoca una función local que se denomina stub, que tiene la misma sintaxis que la función remota deseada, pero que se encarga de agrupar los parámetros en un mensaje y enviarlo al servidor, esperar la respuesta y desampaquetar los datos y retornar el resultado de la invocación.\nEn el servidor ocurre algo análogo: una funcion stub recibe la petición, desempaqueta los parámetros e invoca la función local en el servidor, y luego envía la respuesta a al cliente.\nPaso de parámetros # Aspecto dificultoso del esquema RPC:\n¿Cómo interpretar los párametros? ¿Cómo asegurar la misma representación de los datos? Existen diferencias en las arquitecturas, por ejemplo ordenamiento de los bytes o tamaño de palabras. Distintos lenguajes tiene diferentes tipos de datos. Solución: enviar datos en un formato independiente de la maquina.\nPor ejemplo, se utiliza big endian para ordenar los bytes en los mensajes en la red. Acuerdo en la codificación de tipos basicos y complejos. ¿Cómo pasamos punteros?\nProhibirlos (no es realista) Serializar toda la estructura de datos (por ejemplo el arreglo, lista, etc) Generalmente se puede utilizar un handle. Por ejemplo, nombre de archivo o url. Soporte # Dos alternativas:\nEspecificar detalladamente funciones y parametros, para generar stubs.\nIndicar como empaquetar el nombre de la función y sus parámetros. Representación de los tipos de datos. Decidir en el mecanismo de comunicación, por ejemplo mediante TCP/IP. La interface es especificada mediante un IDL (Interface Definition Language). Mediante un programa específico, la descripción mediante IDL es compilada en stubs. Incorporar la funcionalidad en el lenguaje de programación.\nFacilita el desarrollo de la aplicación. Ej: Java cuenta con RMI (Remote Method Invocation) Descubrimiento:\n¿Cómo puede el cliente saber qué servidor implementa la funcionalidad requerida? Solucion 1: el servidor puede ser bien conocido. Solucion 2: usar un servicio de directorio: El servidor registra en un directorio el servicio que ofrece y su dirección. El cliente contacta el directorio y consulta por un servicio en particular. El cliente se conecta al servidor que le indica el directorio. Variantes # RPC sincrónico: el emisor espera a que el receptor ejecute la función. RPC asincrónico: el emisor sólo espera hasta la confirmación de recepción por parte del emisor. RPC diferido: RPC asincrónico más un callback que se ejecuta al recibir la respuesta del receptor. Alternativamente al callback, el cliente puede realizar un polling. one-way RPC: el emisor genera el RPC pero no espera ni siquiera la confirmación de recepción. RPC Multicast: uso de one-way RPC para enviar múltiples peticiones, posiblemente con un callback. La aplicación puede no conocer que se realiza un multicast, lo oculta el stub. Es posible que tampoco lo sepa el stub, si se realiza mediante multicast en la capa de transporte. ¿Cómo procesar las respuestas? ¿La primera unicamente, todas? Depende de la aplicación. "},{"id":4,"href":"/docs/04-comunicacion-mom/","title":"Middleware orientado a mensajes (MoM)","section":"Docs","content":" Middleware orientado a mensajes (MoM) # RPC o RMI no siempre son apropiados. Ej:\nel receptor no esta funcionando al mismo tiempo que el emisor. no se ajustan a la arquitectura cliente/servidor. Alternativa: envío de mensajes.\nUso de sockets # Socket: abstraccion sobre un puerto, donde se puede escribir o leer datos, usando un protocolo específico (ej: TCP o UDP).\nNo presenta el nivel de abstracción necesario. Cualquier funcionalidad adicional debe ser implementada por la aplicación.\nUso de patrones # La mayoría de las comunicaciones realizadas por las aplicaciones pueden ser categorizadas en unos pocos patrones:\nEj: request-reply, publish-subscribe, pipeline\nEj de implementación: ZeroMQ.\nMPI # Uso de paso de mensajes en computación de alto perfomance, por ejemplo clusters. TCP esta orientado a su uso sobre IP, por lo cual no es necesariamente efectivo en estas situaciones.\nEl estándar MPI se definio para lograr interoperabilidad entre soluciones de paso de mensajes para este tipo de escenarios.\nEj: no asume que un error en la red es recuperable.\nConsidera grupos de procesos, donde cada proceso tiene un identificador (grupoID, procesoID). Un proceso puede pertenecer a mas de un grupo.\nMas de 650 operaciones definidas.\nComunicación persistente # Sistemas de manejos de colas: ofrecen soporte para la comunicación asincrónica persistente.\nIdea básica: las aplicaciones se comunican enviando mensajes a buzones. Estos mensajes pueden a su vez ser reenviados a otros servidores de colas. En general cada aplicación tiene asociada una cola de mensajes.\nGarantía: en general se da la garantía que el mensaje será puesto en la cola de mensajes del receptor, pero no que este lo leerá.\nEmisor y receptor quedan así totalmente desacoplados en tiempo y espacio.\nEl contenido de los mensajes es arbitrario, aunque posiblemente limitado en tamaño. Solamente debe estar correctamente indicado el receptor.\nPrimitivas: PUT, GET, POLL, NOTIFY.\nArquitectura de un MoM # En general las colas de mensajes son responsabilidad de un administrador de colas de mensajes (queue manager).\nEn general el administrador de colas de mensajes es un proceso separado del cliente y/o el emisor.\nEl administrador tiene la responsabilidad de \u0026ldquo;rutear\u0026rdquo; los mensajes correctamente.\nEn general las direcciones de las colas de mensajes deben proveer transparencia de ubicación.\nUna cuestión a tener en cuenta es cómo informar a los distinos administradores de las direcciones existentes.\nEn sistemas complejos, no es realista que un administrador conozca a todo el resto: se debe rutear los mensajes con información incompleta (problema analogo a los routers en una red IP). Se utiliza una red superpuesta.\nBrokers # Un uso común de los sistemas de mensajes es integrar aplicaciones nuevas y existentes en un sistema coherente (¿suena?)\nLa integración requiere que las aplicaciones comprendan los mensajes que reciben del resto.\nEsto requiere que cada aplicacion entienda la sintaxis y la semántica de los protocolos utilizados por el resto.\nSoluciones?\nCada aplicación convierte los mensajes: impráctico, en un sistema con N aplicaciones, se requieren N^2 convertidores. Protocolo común: no es realista, dada la heterogeneidad de las aplicaciones. Información de sintaxis en cada mensaje: ejemplo, con esquemas XML. Falta entender la semántica. Entonces? No se puede esconder la situación, por lo tanto se debe ofrecer un mecanismo lo más simple posible para las conversiones.\nUn broker es una aplicación en un sistema de mensajería que se encarga de la conversión de mensajes.\nMucho más que un convertidor, puede actuar también como un gateway a nivel de aplicación:\nManejo de publicación/subscripción. Prioridades. Multicasting. Logging. Balanceo de carga. Etc. Para todo esto, un broker maneja una serie de reglas de transformación, ruteo, etc., que deben ser configuradas por un experto.\nEjemplo: AMQP # Advanced Message-Queuing Protocol (AMQP).\nAMQP ofrece:\nUn servicio de mensajería. Un protocolo de mensajes. Una interfaz de mensajería para las aplicaciones. Comunicación:\nUna aplicación establece una conexión con el administrador de colas de mensajes. Una conexión incorpora múltiples canales de una sola vía. Conexión -\u0026gt; mayor tiempo de vida, estable Canal -\u0026gt; dinámica, tiempo de vida breve Sesión: agrupamiento lógico de dos canales para comunicación full-duplex Manejo de mensajes:\nTipos de nodos: productor, consumidor, cola Los mensajes pueden ser persistentes (los nodos intermedios deben poder recuperarlo luego de un error) "},{"id":5,"href":"/docs/04-comunicacion-multicast/","title":"Multicast","section":"Docs","content":" Multicast # ¿Cómo enviar datos a múltiples receptores?\nExisten numerosas soluciones a nivel de protocoles de red y de transporte. Su principal desventaja es el costo en armar las rutas de difusión de datos.\nA nivel de aplicación, las redes p2p estructuradas facilitan la creación de estas rutas de difusión. Veremos técnicas de difusión a este nivel.\nBasada en árboles # La idea básica es que los nodos estan organizados en una red superpuesta, utilizada para difundir los datos.\nLas conexiónes lógicas pueden no ser óptima desde el punto de vista de los enlaces físicos.\nExisten básicamente dos alternativas para la topología:\nArbol: existe un único camino entre dos nodos cualesquiera de la red. Mesh: cada nodo tiene múltiples vecinos y por lo tanto requiere algún tipo de ruteo (existe más de un camino entre dos nodos cualesquiera) Principal diferencia: mesh ofrece mayor tolerancia a fallos que árbol.\nPrincipal desafío: ¿cómo construir la red superpuesta para la difusión?\nAdicional: ¿cómo construimos un árbol de difusión eficiente?\nLa calidad del árbol para multidifusión se puede medir con tres métricas:\nLink stress: ¿cuántas veces debe un paquete atrevesar el mismo enlace? Link stretch: la razón entre el número de saltos en la red superpuesta y los enlaces físicos. Tree cost: métrica global, como reducir el costo agregado de los enlaces. Situación: un nuevo nodo quiere sumarse a la red superpuesta.\nSe contacta con un nodo bien conocido. ¿Cómo decidir que nodo será su nodo padre en el árbol? Para evitar sobrecargar nodos, en general se pone un límite k de nodos vecinos. Este límite dificulta establecer el árbol, ya que agregar un nodo puede requerir una reconfiguración. Inundación (flooding) # Para minimizar el número de nodos que reciben un mensaje del cual no son destinatarios, es mejor construir una red superpuesta con los nodos destino.\nEj: si en una topología de árbol un mensaje solo es para los nodos hoja.\nPosible solución: diferentes redes superpuestas para cada grupo multicast. Desventaja: un nodo puede pertencer a varias redes superpuestas, lo que incrementa el costo de administración.\nUna técnica sencilla de diseminar información a todos los nodos es la inundación:\nEnviar el mensaje a todos los nodos vecinos, excepto de quien lo recibió. Si se mantiene referencia de los mensajes enviados, se puede evitar duplicados. Problema: ineficiente (gran cantidad de mensajes). Sólo sería eficiente si la red superpuesta fuera un árbol.\nSe puede mejorar la situación utilizando inundación probabilistica:\nUn nodo reenviara el mensaje m a un nodo vecino con una probabilidad p. El número total de mensajes decrece de manera lineal con p. Problema: A menor valor de p, más chances que existan nodos que no reciban el mensaje. Se puede entonces tener en cuenta también el número de nodos vecinos al momento de decidir si reenviar el mensaje o no. ¿Y si la red superpuesta tiene una topología estructurada? Las cosas se hacen más fáciles.\nEjemplo: hipercubo. Reenviar mensajes a nodos con una dimension superior. Total de mensajes: 2^n - 1.\nOtro ejemplo: chord.\nEpidemico # Diseminar información siguiendo un comportamiento similar a los contagios de enfermedades. Como \u0026ldquo;infectar\u0026rdquo; rapidamente todos los nodos con un nuevo dato.\nIdea: difundir rápidamente información utilizando únicamente información local a cada nodo.\nVentaja: es una técnica escalable, requiere pocas sincronizaciones entre nodos.\nSuponemos que las actualizaciones se inician en un único nodo.\nTerminología:\nInfectado: nodo que tiene un dato que desea transmitir. Susceptible: nodo que no ha visto aún este nuevo dato. Removido: nodo que no reenvia datos. Modelos de propagación: antientropía y rumores\nAntientropia # Un nodo P eligue al azar un nodo vecino Q para intercambiar datos.\nP puede sólo envíar datos a Q (push) P puede sólo requerir datos de Q (pull) P y Q intercambian datos (push-pull) Sólo utilizar pull no es eficiente si existen muchos nodos infectados: la probabilidad de escoger un nodo susceptible es baja. Usar push es conveniente cuando el número de nodos infectados es alto. Por lo tanto, la mejor estrategia es push-pull.\nRonda: intervalo de tiempo en el cual cada nodo intercambio datos con un nodo vecino al azar.\n¿Cuántas rondas se necesitan para difundir a todos los nodos una actualización? Orden: O(log(N))\nRumores # Variante de epidémico: si el nodo P contacta un nodo Q al azar para comunicar el dato x. Si Q ya conoce el dato, P dejará de transmitir el dato (con una probabilidad p).\nVentajas: difunde muy rapidamente las actualizaciones. Desventaja: probabilidad de que no todos los nodos sean contactados.\nIncluso con valores bajos de p existe la posibilidad de que algunos nodos no sean actualizados. Para valores altos de p se deben tomar acciones adicionales en caso de que se requiera que la mayoría o todos de los nodos sean actualizados.\nRumores dirigidos # Una presunción que se hace es que un nodo P puede contactar cualquier nodo Q de la red. Esto raramente es así (no se cuenta con una lista completa de los nodos).\nEliminar datos # Los algoritmos epidemicos son excelentes para difundir una actualización.\nProblema: es muy complicado difundir una eliminación.\nSi un nodo elimina el datos x y posteriormente recibe una mensaje viejo de actualización, lo interpretará como un dato nuevo.\nSolución: realizar borrados lógicos, reenviando certificados de defunción.\nProblema: acumulación de certificados.\nSi se sabe que el tiempo de propagación de una actualización es n, se puede eliminar un certificado luego de n\u0026hellip; pero por las dudas, ciertos nodos específicos mantienen copias de estos certificados.\n"},{"id":6,"href":"/docs/05-coordinacion/","title":"Coordinación","section":"Docs","content":" Coordinación # En un sistema centralizado x = timestamp(); y = timestamp() da como resultado \\( x \\leq y \\).\nEn un sistema distribuido, acordar en un valor temporal no es trivial.\n¿Es posible sincronizar los relojes de los nodos de un sistema distribuido? La respuesta es sorprendentemente complicada.\nEntonces\u0026hellip; ¿Cómo coordinan sus actividades los procesos de un sistema distribuido?\nRelojes físicos # Existen situaciones donde es necesario que todos los nodos en un sistema acuerden en un valor de tiempo determinado.\nUn reloj físico presenta deriva\nProblemas:\n¿Cómo sincronizamos el reloj interno con un reloj externo? ¿Cómo sincronizamos los relojes internos entre sí? UTC:\nCoordinated Universal Time Estándar internacional 40 emisoras de onda corta difunden una señal al comienzo de cada segundo UTC Precisión $\\pm 1$ ms a $\\pm 10$ ms Uso de satelites, por ejemplo GPS y relojes atómicos Precisión $\\pm 0,5$ ms Sincronización de relojes:\nSuponer un conjunto de nodos: Desafio 1: que esten sincronizados con una referencia externa, por ejemplo UTC. Desafio 2: que los relojes de los nodos difieran lo menos posible. Exactitud: mantener la desviación con respecto a una fuente externa dentro de un rango específico. Precisión: mantener la desviación entre dos relojes dentro de un rango específico. Sincronización externa: mantener los relojes exactos. Sincronización interna: mantener los relojes precisos. Problema: Los relojes fisicos no son exactos, presentan deriva El reloj por software se basa en el reloj hardware Segun la deriva un reloj puede ser más rapido o más lento en referencia a un reloj ideal Fun facts: Dos relojes exactos pueden ser precisos con una cota $2 \\delta$ Sin embargo, ser precisos no indica nada acerca de la exactitud. Servidor de tiempo:\nObtener un valor actualizado desde un servidor central (por ejemplo, que tenga un reloj UTC) Implementación mediante una arquitectura cliente/servidor: Servidor retorna al cliente respuesta con timestamp. Cliente debe compensar el offset y delay. NTP\nNetwork Time Protocol Ambientes inalambricos:\nRequieren algoritmos diferentes Ejemplo: Reference Broadcast Synchronization Relojes lógicos # Generalmente lo que importa es que los nodos esten de acuerdo en el orden de los eventos.\nRelación happened-before:\n$a$ y $b$ son eventos Si $a$ ocurre antes que $b$ en un mismo proceso, entonces $a \\rightarrow b$ Si $a$ es el envío de un mensaje y $b$ la recepción, entonces $a \\rightarrow b$ Transitivo: si $a \\rightarrow b$ y $b \\rightarrow c$, entonces $a \\rightarrow c$ Introduce un ordenamiento parcial sobre los eventos. Diseño:\nCada evento $e$ tiene asociado un timestamp $C(e)$ Propiedad 1: si $a$ y $b$ son eventos en un mismo proceso y $a \\rightarrow b$ entonces $C(a) \u0026lt; C(b)$ Propiedad 2: si $a$ y $b$ son envío y recepción de un mensaje respectivamente, entonces $C(a) \u0026lt; C(b)$ Implementación:\nCada proceso $P_i$ mantiene un reloj lógico $C_i$ Por cada evento en $P_i$, $C_i = C_i + 1$ Cada mensaje enviado por Pi tiene un timestamp ts(m) = C(i) Cuando Pj recibe un mensaje m: Ajusta su contador Cj con el máximo valor entre Cj y ts(m) Antes de pasar el mensaje a la aplicación, incrementa Cj en uno. El servicio de relojes lógicos es implementado en un middleware, idealmente la aplicación no tiene por que ocuparse.\nEjemplo de uso: multicast totalmente ordenado\nRelojes vectoriales # Al usar relojes lógicos si $C(a) \u0026lt; C(b)$ no implica que $a$ ocurra antes que $b$\nSolución: relojes vectoriales\nCada nodo mantiene su propio reloj lógico Mantiene información de los relojes lógicos del resto de los nodos Se organizan como un vector o arreglo $V[i]$ es el reloj lógico del nodo $i$ $V[j]$ es el reloj lógico del nodo $j$ Ahora el timestamp asociado a cada mensaje es un vector: ts(m) = VC\nPara comparar dos relojes vectoriales, VCa \u0026lt; VCb si y solo si:\nVCa[k] \u0026lt;= VCb[k] para cualquier k existe al menos un k\u0026rsquo; tal que VCa[k\u0026rsquo;] \u0026lt; VCb[k\u0026rsquo;] Si se cumple VCa \u0026lt; VCb entonces un evento precede causalmente a otro.\nImplementación: similar al reloj lógico\nEjemplo de uso: multicast totalmente ordenado.\nExclusión mutua # Coordinar el acceso exclusivo a un recurso.\nEstrategias:\nMediante permisos: acuerdo entre los procesos. Utilizando un token: quien tiene el token, accede al recurso. Centralizado # Uso de un coordinador que otorga el acceso al recurso Facil de implementar, sencillo de mantener. Posibles problemas para escalar. Descentralizado # Recurso con N replicas, cada una con un coordinador asignado. Acceder al recurso requiere votos positivos de al menos m \u0026gt; N/2 coordinadores. Distribuido # Uso de multicast totalmente ordenado para coordinar el acceso. Requiere poder contactar a todos los procesos interesados en el mismo recurso. Token ring # Procesos organizados en un anillo lógico. Token circula por el anillo. Quien tiene el token puede acceder al recurso. Comparación: # Centralizado: Requiere 3 mensajes para acceder/liberar el recurso (petición, recepción del ok, liberación). Distribuido: Si existen N nodos, debo envíar mensajes a cada uno y esperar confirmación de ok: 2(N-1) mensajes. Token-ring: El token puede recorrer indefinidamente el anillo hasta ser retenido para el acceso al recurso. En el peor caso un nodo debe esperar N-1 mensajes hasta que le llegue el token (suponiendo un anillo de N nodos) Ejemplo: exclusion mutua con Zookeeper # En la práctica muchos sistemas distribuidos utilizan un coordinador centralizado\nZookeeper ofrece servicios para:\nexclusion mutua elección de lider monitoreo etc Diseñado para ofrecer confiabilidad, tolerancia a fallas y escalabilidad\nAunque es logicamente un servicio centralizado, su implementación es un sistema distribuido Usar zookeeper o servicios similares: ¡no hay que reinventar la rueda! (sobre todo una rueda complicada)\nZookeeper 101:\nNo hay primitivas bloqueantes Las peticiones de un cliente siempre reciben una respuesta. Ofrece un espacio de nombres, similar a un sistema de archivos. Operaciones: crear y eliminar nodos leer y actualizar datos en nodos (las actualizaciones son completas, no parciales) verificar si existe un nodo en particular Tipos de nodos: persistentes: deben ser creados y eliminados explicitamente efímeros: son eliminados cuando la conexión del proceso que los creo se pierde Servicio de notificaciones Evita polling por parte de los clientes. Ejemplo: obtener acceso exclusivo\nUn proceso crea un nodo, por ejemplo con nombre /lock Si existe, la operación falla indicando que ya existe El proceso debe repetir la operación para obtenerlo En caso de crearlo, para liberar el acceso elimina el nodo /lock Problemas: ¿que sucede cuando un cliente crea /lock y desaparece? Proceso p2 puede solicitar notificaciones por /lock mientras /lock es eliminado Estas sutilezas y muchas más son manejadas por zookeeper. Algoritmos de elección # Muchos algoritmos distribuidos requieren que un nodo actue como coordinador.\nNo importa en general cual nodo en particular sea el coordinador\u0026hellip; pero alguien tiene que hacerlo.\nMediante un algoritmo de elección se escoje un nodo para que actue como coordinador.\nEn general se asume:\nCada proceso P cuenta con un identificador único id(P). Cada proceso conoce a todo el conjunto de procesos (aunque no cuales estan funcionando). El objetivo de estos algoritmos es que cuando finalice la elección todos los procesos hayan acordado el mismo lider.\nAlgoritmo del matón (bully) # Considerar N procesos, cada uno con un identificador k, con k entre 0 y n-1. Cuando un proceso k se da cuenta que el lider no responde: Envía un mensaje ELECTION a todos los nodos con identificador \u0026gt; k. Si ninguno responde, el nodo k asume el papel de líder. Si alguno responde con OK, toma el control del proceso de elección y k desiste. Eventualmente, sólo un proceso tomará el control, enviando el mensaje COORDINATOR. Si un proceso caído retoma su ejecución, inicia una elección. Como el proceso con mayor ID es el que gana, se lo conoce por el nombre de \u0026ldquo;bully algorithm\u0026rdquo;. Elección en un anillo # Suponer que cada nodo conoce su sucesor, y al siguiente a este, y al proximo, y así.\nCuando un nodo detecta que el coordinador no responde:\nEnvía un mensaje ELECTION a su sucesor (o al siguiente si este no responde), con su ID. El receptor reenvia el mensaje ELECTION, agregando su propio ID. Eventualmente, el mensaje retorna al emisor original. En ese momento, el mensaje circula nuevamente ahora con el tipo COORDINATOR. El mensaje contiene ahora: el nuevo coordinador (el ID mas alto) y que nodos estan activos en el anillo. ¿Importa que dos o más procesos inicien una elección?\nNo, únicamente habrá mayor recarga en la red. Elecciones en sistemas de gran escala # Muchos algoritmos de elección suponen un número pequeño de nodos.\nLas cosas se vuelven complicadas a medida que el número de nodos aumenta.\nUn ejemplo es una red blockchain.\nProof of work # Consiste en que los nodos compitan en base a su poder de cómputo\nPara esto, compiten para ver quien es el primero en resolver un problema complejo pero soluble.\nEl ganador es el nodo que primero difunde una solución.\nEl nodo ganador se convierte en el líder: es quien añade la transacción a la cadena de bloques.\nMultiples problemas:\nPrincipalmente, consumo de energía. ¿Cómo regular la complejidad del problema? Proof of stake # Elecciones en redes inalambricas # En una red inalambrica, la transmisión no es necesariamente confiable, ni la topología permanece estática.\nEl algoritmo presentado por Vasudevan escoge el mejor líder.\nPara elegir un líder un nodo difunde un mensaje ELECTION a sus vecinos.\nSi un nodo vecino hubiera recibido ya un mensaje ELECTION, simplemente retorna un ACK.\nCaso contrario, si recibe un mensaje ELECTION por primera vez recuerda al nodo emisor y retrasmite el mensaje.\nEn cuanto todos los nodos vecinos responda a esta retransmisión de ELECTION, el nodo responde al emisor original.\nCoordinación basada en rumores # Se puede utilizar rumores para recolectar información.\nConsensuar un mismo valor:\nCada nodo $P_i$ escoge un valor arbitrario $v_i$ Cuando dos nodos $P_i$ y $P_j$ intercambian datos: $v_i, v_j \\leftarrow (v_i + v_j)/2$ Eventualmente todos los nodos tendran el mismo valor (media de los valores iniciales) Estimar el número de nodos:\nEl nodo $P_1$ escoge $v_1=1$, el resto de los nodos $v_i=0$ Si hay $N$ nodos, eventualmente todos tendran $v_i=1/N$ Se puede estimar el tamaño de la red como $1/v_i$ Seleccionar un nodo al azar:\nCada nodo $P_i$ seleccionar un valor $m_i$ al azar y setea $v_i=m_i$ Al intercambiar datos $P_i$ y $P_j$ realizan $v_i, v_j \\leftarrow max{v_i, v_j}$ Si luego $m_i \u0026lt; v_i$, entonces el nodo $P_i$ pierde la competencia. Eventualmente un único nodo será el ganador. Aplicacion\nUn nodo al azar inicia el proceso de estimación de números de nodos. Si el numero de nodos es estable, se puede designar un nodo fijo para que realice el conteo. Caso contrario, se pueden utilizar epocas o bien un nodo al azar cada tanto realiza un conteo. Peer-sampling # ¿Cómo elegir un nodo al azar cuando no se conoce la totalidad de los nodos en el sistema?\nUn nodo podría tener toda la información, pero no es una solución escalable.\nUna solución es el uso de vistas parciales:\nCada nodo mantiene una lista de c nodos vecinos. Los nodos intercambian parte de sus listas parciales con otros nodos (en su vista parcial). Cada nodo actualiza su vista parcial, pero siempre manteniendo c nodos en la misma. Si esto se repite regularmente, escoger un nodo al azar de la vista parcial es estadisticamente indistinguible de hacerlo de la totalidad de los nodos.\nConstruccion de redes superpuestas # Es posible utilizar las vistas parciales para generar topologías estructuradas.\nUn posible protocolo para lograrlo estaría dividido en dos capas:\nUna capa inferior que mantiene la vista parcial y opera sobre la red no-estructurada. Una capa superior que genera una topología estructurada en base a la vista parcial. Rumores seguros # La velocidad de propagación de datos puede generar problemas de seguridad/confiabilidad.\nPor ejemplo, $c$ nodos pueden cooperar maliciosamente para cooptar la red:\nAl intercambiar las vistas parciales, estos nodos envian $c/2$ entradas que sólo referencian a alguno de estos $c$ nodos. Gradualmente, las vistas parciales de todos los nodos solo contienen referencias a un conjunto de estos $c$ nodos. Se busca tratar de detectar y prevenir comportamiento malicioso\nLos nodos maliciosos pueden ser detectados por el elevado número de referencias desde otros nodos (indegree)\nSin embargo, al detectarlos ya puede ser demasiado tarde\nUna manera de mitigar es requerir que los nodos generen estadísticas:\nAl intercambiar vistas parciales se puede realizar también estadísticas Es importante que no se sepa cuando se utilizan para actualizar la vista parcial o para generar estadísticas Un nodo malicioso no puede devolver siempre enlaces a otros nodos maliciosos, sería rápidamente descubierto No queda otra que, de vez en cuando, \u0026ldquo;jugar con las reglas\u0026rdquo; de los nodos benignos "},{"id":7,"href":"/docs/06-nombres-intro/","title":"Nombres, identificadores y direcciones","section":"Docs","content":" Nombres, identificadores y direcciones # Un nombre es un conjunto de bits que permiten identificar una entidad.\nUna entidad puede ser cualquier cosa: una página web, una impresora, un proceso.\nEn general, una entidad se puede operar.\nPor ejemplo, si la entidad es una impresora, se puede enviar un documento para su impresión. Para operar una entidad se requiere acceder a la misma, mediante un punto de acceso.\nUn punto de acceso es una entidad en un sistema distribuido\u0026hellip; y requiere un nombre. Una entidad puede tener uno, dos o más puntos de acceso. El punto de acceso puede cambiar con el tiempo. Ejemplo: IP:PUERTO El nombre de un punto de acceso se conoce como dirección.\nEs mucho más flexible mantener el nombre de una entidad independiente de su dirección.\nSe conoce como independencia de ubicación Los nombres que refieren univocamente a una entidad se conocen como identificadores\nRefiere a una única entidad. Cada entidad es referida solamente por un identificador. Los identificadores no se reutilizan. En general, nombres e identificadores son representados machine-readable.\nOtros nombres son diseñados para que sean fácilmente legibles por un humano.\nEjemplo: nombres de archivo, DNS ¿Cómo resolvemos un nombre a una entidad? Dos opciones:\nMantener un registro (nombre, dirección) Realizar un ruteo hacia la dirección o punto de acceso "},{"id":8,"href":"/docs/06-nombres-planos/","title":"Nombres planos","section":"Docs","content":" Nombres planos # No contienen ningún tipo de información acerca de la entidad ni de su punto de acceso.\nEjemplo: una dirección representada como una cadena aleatoria de bits.\n¿Cómo se puede resolver la entidad asociada?\nBroadcast # Para resolver un nombre plano se realiza un broadcast del identificador.\nUna red LAN (cableada o wireless) ofrece servicios eficientes de broadcast.\nCada máquina chequea si contiene la entidad asociada al identificador.\nEjemplo: ARP\nA medida que la red incrementa su tamaño, el uso de broadcast se vuelve ineficiente.\nAlternativa: multicasting\nEvita interrumpir nodos que no esten interesados en el mensaje.\nPosible de implementar en redes Ethernet\nEn IP se puede definir grupos de multicasting, identificados mediante una dirección.\nÚtil como mecanismo de ubicación\nSe puede utilizar para enviar la petición a múltiples replicas.\nForwarding Pointers # Mantener una referencia a la nueva ubicación una entidad.\nEjemplo: si una entidad se mueve de A a B, entonces en A queda una referencia a B.\nEs sencillo, basta seguir la cadena de referencias para ubicar la entidad.\nDesventajas:\nLa cadena de referencias puede terminar siendo demasiado extensa.\nLas ubicaciones intermedias deben preservar la referencia.\nLa cadena de referencias es vulnerable a la pérdida de alguno de sus componentes.\nBasados en hogar (home-based) # Consiste en mantener una referencia a la ubicación actual de una entidad.\nLa referencia se mantiene en una entidad conocida como home location\nUtilizado para referir entidades móbiles en redes de gran escala\nMecanismo de respaldo para servicios basados en forwarding pointers\nEjemplo: Mobile IP\nOfrece un elevado nivel de trasnparencia de ubicación.\nFuncionamiento:\nCada nodo móvil tiene una IP fija.\nLa comunicación inicial con el nodo móvil se realiza con el home agent\nEl home agent reside en la red inicial\nCuando el nodo se mueve a otra red, solicita una nueva IP que es registrada en el home agent\nCuando el home agent recibe un request para el nodo, reenvia el paquete al nodo.\nEl emisor es informado por el home agent de la ubicación del nodo móvil.\nEste proceso se oculta en lo posible a la aplicación.\nDesventajas:\nIncremento de latencia.\nLa ubicación hogar siempre tiene que existir.\n"},{"id":9,"href":"/docs/06-nombres-planos-chord/","title":"Nombres planos - DHT","section":"Docs","content":" Chord # Chord es un sistema DHT (Distributed Hash Table) relativamente sencillo de entender.\nMecanismo general # Usa un espacio de $m$ bits para asignar identificadores a nodos y claves a entidades.\nEl número $m$ de bits usualmente esta entre 128 y 160.\nUna entidad con clave $k$ es administrada por el nodo cuyo identificador $id$ sea $id \\geq k$.\nA dicho nodo se le denomina sucesor de $k$ y se denota como $succ(k)$\nProblema: ¿Cómo resolver eficientemente $k$ a la dirección de $succ(k)$?\nSolución lineal # xxx\nTablas finger # yyy\n"},{"id":10,"href":"/docs/07-replicacion/07-replicacion/","title":"Replicacion","section":"Docs","content":" hola # "},{"id":11,"href":"/docs/","title":"Docs","section":"","content":" Unidades # "},{"id":12,"href":"/posts/06-nombres-planos/","title":"Nombres planos","section":"Posts","content":"No contienen ningún tipo de información acerca de la entidad ni de su punto de acceso.\nEjemplo: una dirección representada como una cadena aleatoria de bits.\n¿Cómo se puede resolver la entidad asociada?\nBroadcast # Para resolver un nombre plano se realiza un broadcast del identificador.\nUna red LAN (cableada o wireless) ofrece servicios eficientes de broadcast.\nCada máquina chequea si contiene la entidad asociada al identificador.\nEjemplo: ARP\nA medida que la red incrementa su tamaño, el uso de broadcast se vuelve ineficiente.\nAlternativa: multicasting\nEvita interrumpir nodos que no esten interesados en el mensaje.\nPosible de implementar en redes Ethernet\nEn IP se puede definir grupos de multicasting, identificados mediante una dirección.\nÚtil como mecanismo de ubicación\nSe puede utilizar para enviar la petición a múltiples replicas.\nForwarding Pointers # Mantener una referencia a la nueva ubicación una entidad.\nEjemplo: si una entidad se mueve de A a B, entonces en A queda una referencia a B.\nEs sencillo, basta seguir la cadena de referencias para ubicar la entidad.\nDesventajas:\nLa cadena de referencias puede terminar siendo demasiado extensa.\nLas ubicaciones intermedias deben preservar la referencia.\nLa cadena de referencias es vulnerable a la pérdida de alguno de sus componentes.\nBasados en hogar (home-based) # Consiste en mantener una referencia a la ubicación actual de una entidad.\nLa referencia se mantiene en una entidad conocida como home location\nUtilizado para referir entidades móbiles en redes de gran escala\nMecanismo de respaldo para servicios basados en forwarding pointers\nEjemplo: Mobile IP\nOfrece un elevado nivel de trasnparencia de ubicación.\nFuncionamiento:\nCada nodo móvil tiene una IP fija.\nLa comunicación inicial con el nodo móvil se realiza con el home agent\nEl home agent reside en la red inicial\nCuando el nodo se mueve a otra red, solicita una nueva IP que es registrada en el home agent\nCuando el home agent recibe un request para el nodo, reenvia el paquete al nodo.\nEl emisor es informado por el home agent de la ubicación del nodo móvil.\nEste proceso se oculta en lo posible a la aplicación.\nDesventajas:\nIncremento de latencia.\nLa ubicación hogar siempre tiene que existir.\n"},{"id":13,"href":"/posts/06-nombres-planos-chord/","title":"Nombres planos - DHT","section":"Posts","content":"Chord es un sistema DHT (Distributed Hash Table) relativamente sencillo de entender.\nMecanismo general # Usa un espacio de $m$ bits para asignar identificadores a nodos y claves a entidades.\nEl número $m$ de bits usualmente esta entre 128 y 160.\nUna entidad con clave $k$ es administrada por el nodo cuyo identificador $id$ sea $id \\geq k$.\nA dicho nodo se le denomina sucesor de $k$ y se denota como $succ(k)$\nProblema: ¿Cómo resolver eficientemente $k$ a la dirección de $succ(k)$?\nSolución lineal # xxx\nTablas finger # yyy\n"},{"id":14,"href":"/posts/06-nombres-intro/","title":"Nombres, identificadores y direcciones","section":"Posts","content":"Un nombre es un conjunto de bits que permiten identificar una entidad.\nUna entidad puede ser cualquier cosa: una página web, una impresora, un proceso.\nEn general, una entidad se puede operar.\nPor ejemplo, si la entidad es una impresora, se puede enviar un documento para su impresión. Para operar una entidad se requiere acceder a la misma, mediante un punto de acceso.\nUn punto de acceso es una entidad en un sistema distribuido\u0026hellip; y requiere un nombre. Una entidad puede tener uno, dos o más puntos de acceso. El punto de acceso puede cambiar con el tiempo. Ejemplo: IP:PUERTO El nombre de un punto de acceso se conoce como dirección.\nEs mucho más flexible mantener el nombre de una entidad independiente de su dirección.\nSe conoce como independencia de ubicación Los nombres que refieren univocamente a una entidad se conocen como identificadores\nRefiere a una única entidad. Cada entidad es referida solamente por un identificador. Los identificadores no se reutilizan. En general, nombres e identificadores son representados machine-readable.\nOtros nombres son diseñados para que sean fácilmente legibles por un humano.\nEjemplo: nombres de archivo, DNS ¿Cómo resolvemos un nombre a una entidad? Dos opciones:\nMantener un registro (nombre, dirección) Realizar un ruteo hacia la dirección o punto de acceso "},{"id":15,"href":"/posts/05-coordinacion/","title":"Coordinación","section":"Posts","content":"En un sistema centralizado x = timestamp(); y = timestamp() da como resultado $x \\leq y$.\nEn un sistema distribuido, acordar en un valor temporal no es trivial.\n¿Es posible sincronizar los relojes de los nodos de un sistema distribuido? La respuesta es sorprendentemente complicada.\nEntonces\u0026hellip; ¿Cómo coordinan sus actividades los procesos de un sistema distribuido?\nRelojes físicos # Existen situaciones donde es necesario que todos los nodos en un sistema acuerden en un valor de tiempo determinado.\nUn reloj físico presenta deriva\nProblemas:\n¿Cómo sincronizamos el reloj interno con un reloj externo? ¿Cómo sincronizamos los relojes internos entre sí? UTC:\nCoordinated Universal Time Estándar internacional 40 emisoras de onda corta difunden una señal al comienzo de cada segundo UTC Precisión $\\pm 1$ ms a $\\pm 10$ ms Uso de satelites, por ejemplo GPS y relojes atómicos Precisión $\\pm 0,5$ ms Sincronización de relojes:\nSuponer un conjunto de nodos: Desafio 1: que esten sincronizados con una referencia externa, por ejemplo UTC. Desafio 2: que los relojes de los nodos difieran lo menos posible. Exactitud: mantener la desviación con respecto a una fuente externa dentro de un rango específico. Precisión: mantener la desviación entre dos relojes dentro de un rango específico. Sincronización externa: mantener los relojes exactos. Sincronización interna: mantener los relojes precisos. Problema: Los relojes fisicos no son exactos, presentan deriva El reloj por software se basa en el reloj hardware Segun la deriva un reloj puede ser más rapido o más lento en referencia a un reloj ideal Fun facts: Dos relojes exactos pueden ser precisos con una cota $2 \\delta$ Sin embargo, ser precisos no indica nada acerca de la exactitud. Servidor de tiempo:\nObtener un valor actualizado desde un servidor central (por ejemplo, que tenga un reloj UTC) Implementación mediante una arquitectura cliente/servidor: Servidor retorna al cliente respuesta con timestamp. Cliente debe compensar el offset y delay. NTP\nNetwork Time Protocol Ambientes inalambricos:\nRequieren algoritmos diferentes Ejemplo: Reference Broadcast Synchronization Relojes lógicos # Generalmente lo que importa es que los nodos esten de acuerdo en el orden de los eventos.\nRelación happened-before:\n$a$ y $b$ son eventos Si $a$ ocurre antes que $b$ en un mismo proceso, entonces $a \\rightarrow b$ Si $a$ es el envío de un mensaje y $b$ la recepción, entonces $a \\rightarrow b$ Transitivo: si $a \\rightarrow b$ y $b \\rightarrow c$, entonces $a \\rightarrow c$ Introduce un ordenamiento parcial sobre los eventos. Diseño:\nCada evento $e$ tiene asociado un timestamp $C(e)$ Propiedad 1: si $a$ y $b$ son eventos en un mismo proceso y $a \\rightarrow b$ entonces $C(a) \u0026lt; C(b)$ Propiedad 2: si $a$ y $b$ son envío y recepción de un mensaje respectivamente, entonces $C(a) \u0026lt; C(b)$ Implementación:\nCada proceso $P_i$ mantiene un reloj lógico $C_i$ Por cada evento en $P_i$, $C_i = C_i + 1$ Cada mensaje enviado por Pi tiene un timestamp ts(m) = C(i) Cuando Pj recibe un mensaje m: Ajusta su contador Cj con el máximo valor entre Cj y ts(m) Antes de pasar el mensaje a la aplicación, incrementa Cj en uno. El servicio de relojes lógicos es implementado en un middleware, idealmente la aplicación no tiene por que ocuparse.\nEjemplo de uso: multicast totalmente ordenado\nRelojes vectoriales # Al usar relojes lógicos si $C(a) \u0026lt; C(b)$ no implica que $a$ ocurra antes que $b$\nSolución: relojes vectoriales\nCada nodo mantiene su propio reloj lógico Mantiene información de los relojes lógicos del resto de los nodos Se organizan como un vector o arreglo $V[i]$ es el reloj lógico del nodo $i$ $V[j]$ es el reloj lógico del nodo $j$ Ahora el timestamp asociado a cada mensaje es un vector: ts(m) = VC\nPara comparar dos relojes vectoriales, VCa \u0026lt; VCb si y solo si:\nVCa[k] \u0026lt;= VCb[k] para cualquier k existe al menos un k\u0026rsquo; tal que VCa[k\u0026rsquo;] \u0026lt; VCb[k\u0026rsquo;] Si se cumple VCa \u0026lt; VCb entonces un evento precede causalmente a otro.\nImplementación: similar al reloj lógico\nEjemplo de uso: multicast totalmente ordenado.\nExclusión mutua # Coordinar el acceso exclusivo a un recurso.\nEstrategias:\nMediante permisos: acuerdo entre los procesos. Utilizando un token: quien tiene el token, accede al recurso. Centralizado # Uso de un coordinador que otorga el acceso al recurso Facil de implementar, sencillo de mantener. Posibles problemas para escalar. Descentralizado # Recurso con N replicas, cada una con un coordinador asignado. Acceder al recurso requiere votos positivos de al menos m \u0026gt; N/2 coordinadores. Distribuido # Uso de multicast totalmente ordenado para coordinar el acceso. Requiere poder contactar a todos los procesos interesados en el mismo recurso. Token ring # Procesos organizados en un anillo lógico. Token circula por el anillo. Quien tiene el token puede acceder al recurso. Comparación: # Centralizado: Requiere 3 mensajes para acceder/liberar el recurso (petición, recepción del ok, liberación). Distribuido: Si existen N nodos, debo envíar mensajes a cada uno y esperar confirmación de ok: 2(N-1) mensajes. Token-ring: El token puede recorrer indefinidamente el anillo hasta ser retenido para el acceso al recurso. En el peor caso un nodo debe esperar N-1 mensajes hasta que le llegue el token (suponiendo un anillo de N nodos) Ejemplo: exclusion mutua con Zookeeper # En la práctica muchos sistemas distribuidos utilizan un coordinador centralizado\nZookeeper ofrece servicios para:\nexclusion mutua elección de lider monitoreo etc Diseñado para ofrecer confiabilidad, tolerancia a fallas y escalabilidad\nAunque es logicamente un servicio centralizado, su implementación es un sistema distribuido Usar zookeeper o servicios similares: ¡no hay que reinventar la rueda! (sobre todo una rueda complicada)\nZookeeper 101:\nNo hay primitivas bloqueantes Las peticiones de un cliente siempre reciben una respuesta. Ofrece un espacio de nombres, similar a un sistema de archivos. Operaciones: crear y eliminar nodos leer y actualizar datos en nodos (las actualizaciones son completas, no parciales) verificar si existe un nodo en particular Tipos de nodos: persistentes: deben ser creados y eliminados explicitamente efímeros: son eliminados cuando la conexión del proceso que los creo se pierde Servicio de notificaciones Evita polling por parte de los clientes. Ejemplo: obtener acceso exclusivo\nUn proceso crea un nodo, por ejemplo con nombre /lock Si existe, la operación falla indicando que ya existe El proceso debe repetir la operación para obtenerlo En caso de crearlo, para liberar el acceso elimina el nodo /lock Problemas: ¿que sucede cuando un cliente crea /lock y desaparece? Proceso p2 puede solicitar notificaciones por /lock mientras /lock es eliminado Estas sutilezas y muchas más son manejadas por zookeeper. Algoritmos de elección # Muchos algoritmos distribuidos requieren que un nodo actue como coordinador.\nNo importa en general cual nodo en particular sea el coordinador\u0026hellip; pero alguien tiene que hacerlo.\nMediante un algoritmo de elección se escoje un nodo para que actue como coordinador.\nEn general se asume:\nCada proceso P cuenta con un identificador único id(P). Cada proceso conoce a todo el conjunto de procesos (aunque no cuales estan funcionando). El objetivo de estos algoritmos es que cuando finalice la elección todos los procesos hayan acordado el mismo lider.\nAlgoritmo del matón (bully) # Considerar N procesos, cada uno con un identificador k, con k entre 0 y n-1. Cuando un proceso k se da cuenta que el lider no responde: Envía un mensaje ELECTION a todos los nodos con identificador \u0026gt; k. Si ninguno responde, el nodo k asume el papel de líder. Si alguno responde con OK, toma el control del proceso de elección y k desiste. Eventualmente, sólo un proceso tomará el control, enviando el mensaje COORDINATOR. Si un proceso caído retoma su ejecución, inicia una elección. Como el proceso con mayor ID es el que gana, se lo conoce por el nombre de \u0026ldquo;bully algorithm\u0026rdquo;. Elección en un anillo # Suponer que cada nodo conoce su sucesor, y al siguiente a este, y al proximo, y así.\nCuando un nodo detecta que el coordinador no responde:\nEnvía un mensaje ELECTION a su sucesor (o al siguiente si este no responde), con su ID. El receptor reenvia el mensaje ELECTION, agregando su propio ID. Eventualmente, el mensaje retorna al emisor original. En ese momento, el mensaje circula nuevamente ahora con el tipo COORDINATOR. El mensaje contiene ahora: el nuevo coordinador (el ID mas alto) y que nodos estan activos en el anillo. ¿Importa que dos o más procesos inicien una elección?\nNo, únicamente habrá mayor recarga en la red. Elecciones en sistemas de gran escala # Muchos algoritmos de elección suponen un número pequeño de nodos.\nLas cosas se vuelven complicadas a medida que el número de nodos aumenta.\nUn ejemplo es una red blockchain.\nProof of work # Consiste en que los nodos compitan en base a su poder de cómputo\nPara esto, compiten para ver quien es el primero en resolver un problema complejo pero soluble.\nEl ganador es el nodo que primero difunde una solución.\nEl nodo ganador se convierte en el líder: es quien añade la transacción a la cadena de bloques.\nMultiples problemas:\nPrincipalmente, consumo de energía. ¿Cómo regular la complejidad del problema? Proof of stake # Elecciones en redes inalambricas # En una red inalambrica, la transmisión no es necesariamente confiable, ni la topología permanece estática.\nEl algoritmo presentado por Vasudevan escoge el mejor líder.\nPara elegir un líder un nodo difunde un mensaje ELECTION a sus vecinos.\nSi un nodo vecino hubiera recibido ya un mensaje ELECTION, simplemente retorna un ACK.\nCaso contrario, si recibe un mensaje ELECTION por primera vez recuerda al nodo emisor y retrasmite el mensaje.\nEn cuanto todos los nodos vecinos responda a esta retransmisión de ELECTION, el nodo responde al emisor original.\nCoordinación basada en rumores # Se puede utilizar rumores para recolectar información.\nConsensuar un mismo valor:\nCada nodo $P_i$ escoge un valor arbitrario $v_i$ Cuando dos nodos $P_i$ y $P_j$ intercambian datos: $v_i, v_j \\leftarrow (v_i + v_j)/2$ Eventualmente todos los nodos tendran el mismo valor (media de los valores iniciales) Estimar el número de nodos:\nEl nodo $P_1$ escoge $v_1=1$, el resto de los nodos $v_i=0$ Si hay $N$ nodos, eventualmente todos tendran $v_i=1/N$ Se puede estimar el tamaño de la red como $1/v_i$ Seleccionar un nodo al azar:\nCada nodo $P_i$ seleccionar un valor $m_i$ al azar y setea $v_i=m_i$ Al intercambiar datos $P_i$ y $P_j$ realizan $v_i, v_j \\leftarrow max{v_i, v_j}$ Si luego $m_i \u0026lt; v_i$, entonces el nodo $P_i$ pierde la competencia. Eventualmente un único nodo será el ganador. Aplicacion\nUn nodo al azar inicia el proceso de estimación de números de nodos. Si el numero de nodos es estable, se puede designar un nodo fijo para que realice el conteo. Caso contrario, se pueden utilizar epocas o bien un nodo al azar cada tanto realiza un conteo. Peer-sampling # ¿Cómo elegir un nodo al azar cuando no se conoce la totalidad de los nodos en el sistema?\nUn nodo podría tener toda la información, pero no es una solución escalable.\nUna solución es el uso de vistas parciales:\nCada nodo mantiene una lista de c nodos vecinos. Los nodos intercambian parte de sus listas parciales con otros nodos (en su vista parcial). Cada nodo actualiza su vista parcial, pero siempre manteniendo c nodos en la misma. Si esto se repite regularmente, escoger un nodo al azar de la vista parcial es estadisticamente indistinguible de hacerlo de la totalidad de los nodos.\nConstruccion de redes superpuestas # Es posible utilizar las vistas parciales para generar topologías estructuradas.\nUn posible protocolo para lograrlo estaría dividido en dos capas:\nUna capa inferior que mantiene la vista parcial y opera sobre la red no-estructurada. Una capa superior que genera una topología estructurada en base a la vista parcial. Rumores seguros # La velocidad de propagación de datos puede generar problemas de seguridad/confiabilidad.\nPor ejemplo, $c$ nodos pueden cooperar maliciosamente para cooptar la red:\nAl intercambiar las vistas parciales, estos nodos envian $c/2$ entradas que sólo referencian a alguno de estos $c$ nodos. Gradualmente, las vistas parciales de todos los nodos solo contienen referencias a un conjunto de estos $c$ nodos. Se busca tratar de detectar y prevenir comportamiento malicioso\nLos nodos maliciosos pueden ser detectados por el elevado número de referencias desde otros nodos (indegree)\nSin embargo, al detectarlos ya puede ser demasiado tarde\nUna manera de mitigar es requerir que los nodos generen estadísticas:\nAl intercambiar vistas parciales se puede realizar también estadísticas Es importante que no se sepa cuando se utilizan para actualizar la vista parcial o para generar estadísticas Un nodo malicioso no puede devolver siempre enlaces a otros nodos maliciosos, sería rápidamente descubierto No queda otra que, de vez en cuando, \u0026ldquo;jugar con las reglas\u0026rdquo; de los nodos benignos "},{"id":16,"href":"/posts/04-comunicacion-multicast/","title":"Multicast","section":"Posts","content":"¿Cómo enviar datos a múltiples receptores?\nExisten numerosas soluciones a nivel de protocoles de red y de transporte. Su principal desventaja es el costo en armar las rutas de difusión de datos.\nA nivel de aplicación, las redes p2p estructuradas facilitan la creación de estas rutas de difusión. Veremos técnicas de difusión a este nivel.\nBasada en árboles # La idea básica es que los nodos estan organizados en una red superpuesta, utilizada para difundir los datos.\nLas conexiónes lógicas pueden no ser óptima desde el punto de vista de los enlaces físicos.\nExisten básicamente dos alternativas para la topología:\nArbol: existe un único camino entre dos nodos cualesquiera de la red. Mesh: cada nodo tiene múltiples vecinos y por lo tanto requiere algún tipo de ruteo (existe más de un camino entre dos nodos cualesquiera) Principal diferencia: mesh ofrece mayor tolerancia a fallos que árbol.\nPrincipal desafío: ¿cómo construir la red superpuesta para la difusión?\nAdicional: ¿cómo construimos un árbol de difusión eficiente?\nLa calidad del árbol para multidifusión se puede medir con tres métricas:\nLink stress: ¿cuántas veces debe un paquete atrevesar el mismo enlace? Link stretch: la razón entre el número de saltos en la red superpuesta y los enlaces físicos. Tree cost: métrica global, como reducir el costo agregado de los enlaces. Situación: un nuevo nodo quiere sumarse a la red superpuesta.\nSe contacta con un nodo bien conocido. ¿Cómo decidir que nodo será su nodo padre en el árbol? Para evitar sobrecargar nodos, en general se pone un límite k de nodos vecinos. Este límite dificulta establecer el árbol, ya que agregar un nodo puede requerir una reconfiguración. Inundación (flooding) # Para minimizar el número de nodos que reciben un mensaje del cual no son destinatarios, es mejor construir una red superpuesta con los nodos destino.\nEj: si en una topología de árbol un mensaje solo es para los nodos hoja.\nPosible solución: diferentes redes superpuestas para cada grupo multicast. Desventaja: un nodo puede pertencer a varias redes superpuestas, lo que incrementa el costo de administración.\nUna técnica sencilla de diseminar información a todos los nodos es la inundación:\nEnviar el mensaje a todos los nodos vecinos, excepto de quien lo recibió. Si se mantiene referencia de los mensajes enviados, se puede evitar duplicados. Problema: ineficiente (gran cantidad de mensajes). Sólo sería eficiente si la red superpuesta fuera un árbol.\nSe puede mejorar la situación utilizando inundación probabilistica:\nUn nodo reenviara el mensaje m a un nodo vecino con una probabilidad p. El número total de mensajes decrece de manera lineal con p. Problema: A menor valor de p, más chances que existan nodos que no reciban el mensaje. Se puede entonces tener en cuenta también el número de nodos vecinos al momento de decidir si reenviar el mensaje o no. ¿Y si la red superpuesta tiene una topología estructurada? Las cosas se hacen más fáciles.\nEjemplo: hipercubo. Reenviar mensajes a nodos con una dimension superior. Total de mensajes: 2^n - 1.\nOtro ejemplo: chord.\nEpidemico # Diseminar información siguiendo un comportamiento similar a los contagios de enfermedades. Como \u0026ldquo;infectar\u0026rdquo; rapidamente todos los nodos con un nuevo dato.\nIdea: difundir rápidamente información utilizando únicamente información local a cada nodo.\nVentaja: es una técnica escalable, requiere pocas sincronizaciones entre nodos.\nSuponemos que las actualizaciones se inician en un único nodo.\nTerminología:\nInfectado: nodo que tiene un dato que desea transmitir. Susceptible: nodo que no ha visto aún este nuevo dato. Removido: nodo que no reenvia datos. Modelos de propagación:\nAntientropia: Un nodo P eligue al azar un nodo vecino Q para intercambiar datos.\nP puede sólo envíar datos a Q (push) P puede sólo requerir datos de Q (pull) P y Q intercambian datos (push-pull) Sólo utilizar pull no es eficiente si existen muchos nodos infectados: la probabilidad de escoger un nodo susceptible es baja. Usar push es conveniente cuando el número de nodos infectados es alto. Por lo tanto, la mejor estrategia es push-pull.\nRonda: intervalo de tiempo en el cual cada nodo intercambio datos con un nodo vecino al azar.\n¿Cuántas rondas se necesitan para difundir a todos los nodos una actualización? Orden: O(log(N))\nRumores # Variante de epidémico: si el nodo P contacta un nodo Q al azar para comunicar el dato x. Si Q ya conoce el dato, P dejará de transmitir el dato (con una probabilidad p).\nVentajas: difunde muy rapidamente las actualizaciones. Desventaja: probabilidad de que no todos los nodos sean contactados.\nIncluso con valores bajos de p existe la posibilidad de que algunos nodos no sean actualizados. Para valores altos de p se deben tomar acciones adicionales en caso de que se requiera que la mayoría o todos de los nodos sean actualizados.\nDirigido # Una presunción que se hace es que un nodo P puede contactar cualquier nodo Q de la red. Esto raramente es así (no se cuenta con una lista completa de los nodos).\nEliminar datos # Los algoritmos epidemicos son excelentes para difundir una actualización.\nProblema: es muy complicado difundir una eliminación.\nSi un nodo elimina el datos x y posteriormente recibe una mensaje viejo de actualización, lo interpretará como un dato nuevo.\nSolución: realizar borrados lógicos, reenviando certificados de defunción.\nProblema: acumulación de certificados.\nSi se sabe que el tiempo de propagación de una actualización es n, se puede eliminar un certificado luego de n\u0026hellip; pero por las dudas, ciertos nodos específicos mantienen copias de estos certificados.\n"},{"id":17,"href":"/posts/04-comunicacion-mom/","title":"Middleware orientado a mensajes (MoM)","section":"Posts","content":"RPC o RMI no siempre son apropiados. Ej:\nel receptor no esta funcionando al mismo tiempo que el emisor. no se ajustan a la arquitectura cliente/servidor. Alternativa: envío de mensajes.\nUso de sockets # Socket: abstraccion sobre un puerto, donde se puede escribir o leer datos, usando un protocolo específico (ej: TCP o UDP).\nNo presenta el nivel de abstracción necesario. Cualquier funcionalidad adicional debe ser implementada por la aplicación.\nUso de patrones # La mayoría de las comunicaciones realizadas por las aplicaciones pueden ser categorizadas en unos pocos patrones:\nEj: request-reply, publish-subscribe, pipeline\nEj de implementación: ZeroMQ.\nMPI # Uso de paso de mensajes en computación de alto perfomance, por ejemplo clusters. TCP esta orientado a su uso sobre IP, por lo cual no es necesariamente efectivo en estas situaciones.\nEl estándar MPI se definio para lograr interoperabilidad entre soluciones de paso de mensajes para este tipo de escenarios.\nEj: no asume que un error en la red es recuperable.\nConsidera grupos de procesos, donde cada proceso tiene un identificador (grupoID, procesoID). Un proceso puede pertenecer a mas de un grupo.\nMas de 650 operaciones definidas.\nComunicación persistente # Sistemas de manejos de colas: ofrecen soporte para la comunicación asincrónica persistente.\nIdea básica: las aplicaciones se comunican enviando mensajes a buzones. Estos mensajes pueden a su vez ser reenviados a otros servidores de colas. En general cada aplicación tiene asociada una cola de mensajes.\nGarantía: en general se da la garantía que el mensaje será puesto en la cola de mensajes del receptor, pero no que este lo leerá.\nEmisor y receptor quedan así totalmente desacoplados en tiempo y espacio.\nEl contenido de los mensajes es arbitrario, aunque posiblemente limitado en tamaño. Solamente debe estar correctamente indicado el receptor.\nPrimitivas: PUT, GET, POLL, NOTIFY.\nArquitectura de un MoM # En general las colas de mensajes son responsabilidad de un administrador de colas de mensajes (queue manager).\nEn general el administrador de colas de mensajes es un proceso separado del cliente y/o el emisor.\nEl administrador tiene la responsabilidad de \u0026ldquo;rutear\u0026rdquo; los mensajes correctamente.\nEn general las direcciones de las colas de mensajes deben proveer transparencia de ubicación.\nUna cuestión a tener en cuenta es cómo informar a los distinos administradores de las direcciones existentes.\nEn sistemas complejos, no es realista que un administrador conozca a todo el resto: se debe rutear los mensajes con información incompleta (problema analogo a los routers en una red IP). Se utiliza una red superpuesta.\nBrokers # Un uso común de los sistemas de mensajes es integrar aplicaciones nuevas y existentes en un sistema coherente (¿suena?)\nLa integración requiere que las aplicaciones comprendan los mensajes que reciben del resto.\nEsto requiere que cada aplicacion entienda la sintaxis y la semántica de los protocolos utilizados por el resto.\nSoluciones?\nCada aplicación convierte los mensajes: impráctico, en un sistema con N aplicaciones, se requieren N^2 convertidores. Protocolo común: no es realista, dada la heterogeneidad de las aplicaciones. Información de sintaxis en cada mensaje: ejemplo, con esquemas XML. Falta entender la semántica. Entonces? No se puede esconder la situación, por lo tanto se debe ofrecer un mecanismo lo más simple posible para las conversiones.\nUn broker es una aplicación en un sistema de mensajería que se encarga de la conversión de mensajes.\nMucho más que un convertidor, puede actuar también como un gateway a nivel de aplicación:\nManejo de publicación/subscripción. Prioridades. Multicasting. Logging. Balanceo de carga. Etc. Para todo esto, un broker maneja una serie de reglas de transformación, ruteo, etc., que deben ser configuradas por un experto.\nEjemplo: AMQP # Advanced Message-Queuing Protocol (AMQP).\nAMQP ofrece:\nUn servicio de mensajería. Un protocolo de mensajes. Una interfaz de mensajería para las aplicaciones. Comunicación:\nUna aplicación establece una conexión con el administrador de colas de mensajes. Una conexión incorpora múltiples canales de una sola vía. Conexión -\u0026gt; mayor tiempo de vida, estable Canal -\u0026gt; dinámica, tiempo de vida breve Sesión: agrupamiento lógico de dos canales para comunicación full-duplex Manejo de mensajes:\nTipos de nodos: productor, consumidor, cola Los mensajes pueden ser persistentes (los nodos intermedios deben poder recuperarlo luego de un error) "},{"id":18,"href":"/posts/04-comunicacion-rpc/","title":"Comunicación","section":"Posts","content":"Fundamental en un sistema distribuido. Las primitivas de comunicación que ofrece el sistema operativo pueden no tener el nivel de abstracción necesario.\nFundaciones # El modelo OSI # Modelo de siete capas, no utilizado en la práctica, pero que es una referencia útil acerca de como esta estructurado lógicamente el stack de comunicación.\nMiddleware # Los servicios middleware para un sistema distribuido estarían logicamente ubicados en las capas de sesión y presentación del modelo OSI, aunque también pueden incorporar servicios en la capa de aplicación.\nTipos de comunicación # El middleware puede ser visto como un servicio adicional que media en la comunicación en una arquitectura cliente/servidor.\nLos tipos de comunicación se pueden categorizar en:\nPersistente:\nEl mensaje es almacenado por el middleware todo el tiempo que sea necesario para realizar la entrega. El emisor no necesita esperar a que se complete la recepción. El receptor no tiene por que estar ejecutando al ser enviado el mensaje. Transitoria:\nEl mensaje es almacenado únicamente el tiempo suficiente para el envío, sólo si emisor y receptor estan ejecutando. Cualquier error descarta el mensaje. Asincrónica:\nEl emisor continua con la ejecución luego de envíar el mensaje, quiza sin confirmación de envío ni recepción. Sincrónica:\nEl emisor se bloquea hasa que el mensaje sea aceptado (envío, recepción, procesamiento). RPC # Los desarrolladores estan familiarizados con el paradigma procedural. Si un procedimiento esta diseñado de manera que funcione aislado, no hay impedimento en principio que pueda ejecutar en otra maquina.\nIdea básica de RPC: Permitir invocar funciones remotas como si fueran locales.\nIdea sencilla pero de implementación compleja. Contribuye a la transparencia de distribución, especialmente a la transparencia de acceso. Problemas: falta de un espacio de direcciones común, diferencia en arquitecturas, caída de alguno de los procesos que se comunican, etc.\nEl proceso cliente invoca una función local que se denomina stub, que tiene la misma sintaxis que la función remota deseada, pero que se encarga de agrupar los parámetros en un mensaje y enviarlo al servidor, esperar la respuesta y desampaquetar los datos y retornar el resultado de la invocación.\nEn el servidor ocurre algo análogo: una funcion stub recibe la petición, desempaqueta los parámetros e invoca la función local en el servidor, y luego envía la respuesta a al cliente.\nPaso de parámetros # Aspecto dificultoso del esquema RPC:\n¿Cómo interpretar los párametros? ¿Cómo asegurar la misma representación de los datos? Existen diferencias en las arquitecturas, por ejemplo ordenamiento de los bytes o tamaño de palabras. Distintos lenguajes tiene diferentes tipos de datos. Solución: enviar datos en un formato independiente de la maquina.\nPor ejemplo, se utiliza big endian para ordenar los bytes en los mensajes en la red. Acuerdo en la codificación de tipos basicos y complejos. ¿Cómo pasamos punteros?\nProhibirlos (no es realista) Serializar toda la estructura de datos (por ejemplo el arreglo, lista, etc) Generalmente se puede utilizar un handle. Por ejemplo, nombre de archivo o url. Soporte # Dos alternativas:\nEspecificar detalladamente funciones y parametros, para generar stubs.\nIndicar como empaquetar el nombre de la función y sus parámetros. Representación de los tipos de datos. Decidir en el mecanismo de comunicación, por ejemplo mediante TCP/IP. La interface es especificada mediante un IDL (Interface Definition Language). Mediante un programa específico, la descripción mediante IDL es compilada en stubs. Incorporar la funcionalidad en el lenguaje de programación.\nFacilita el desarrollo de la aplicación. Ej: Java cuenta con RMI (Remote Method Invocation) Descubrimiento:\n¿Cómo puede el cliente saber qué servidor implementa la funcionalidad requerida? Solucion 1: el servidor puede ser bien conocido. Solucion 2: usar un servicio de directorio: El servidor registra en un directorio el servicio que ofrece y su dirección. El cliente contacta el directorio y consulta por un servicio en particular. El cliente se conecta al servidor que le indica el directorio. Variantes # RPC sincrónico: el emisor espera a que el receptor ejecute la función. RPC asincrónico: el emisor sólo espera hasta la confirmación de recepción por parte del emisor. RPC diferido: RPC asincrónico más un callback que se ejecuta al recibir la respuesta del receptor. Alternativamente al callback, el cliente puede realizar un polling. one-way RPC: el emisor genera el RPC pero no espera ni siquiera la confirmación de recepción. RPC Multicast: uso de one-way RPC para enviar múltiples peticiones, posiblemente con un callback. La aplicación puede no conocer que se realiza un multicast, lo oculta el stub. Es posible que tampoco lo sepa el stub, si se realiza mediante multicast en la capa de transporte. ¿Cómo procesar las respuestas? ¿La primera unicamente, todas? Depende de la aplicación. "},{"id":19,"href":"/posts/02-arquitectura/","title":"Arquitecturas","section":"Posts","content":"Es fundamental una correcta organización para administrar la complejidad de un sistema distribuido.\nPodemos diferenciar:\nLa organización de los componentes de software (arquitectura de software). Cómo están físicamente instanciados (arquitectura del sistema). Estilo arquitectonico # Organización lógica de los componentes de software del sistema:\nComponentes. Unidad modular con interfaces bien definidas (reemplazable). Cómo se conectan y comunican. Conector: el mecanismo que media la comunicación entre los componentes. Qué datos intercambian. Cómo están configurados. Según como se configuran componentes y conectores, tenemos una arquitectura de software.\nArquitecturas tipicamente utilizadas en sistemas distribuidos son:\nArquitecturas por capas. Orientadas a los servicios. Publish-subscribe. Arquitectura por capas # Los componentes se organizan en capas. Un componente en la capa N invoca generalmente los servicios de un componente en la capa N-1. Excepcionalmente, un componente puede invocar un servicio de una capa superior (N+1).\nEjemplo clásico: protocolos de comunicación de redes (TCP/IP, OSI, etc).\nMuchas aplicaciones se organizan en capas siguiendo el siguiente estilo:\nCapa de presentación o interfaz de usuario. Capa de procesamiento o de negocio. Capa de datos o persistencia. Desventaja:\nExiste una dependencia fuerte entre las distintas capas. Orientadas a los servicios # Organización más imprecisa, donde cada componente encapsula un servicio. El sistema se estructura como una composición de servicios.\nOrientado a objetos (invocación de objetos remotos).\nMicroservicios (cada componente representa un servicio separado e independiente).\nBasada en recursos (REST).\nObjetos:\nCada componente corresponde con objeto. Se comunican mediante algún mecanismo de invocación. Encapsular datos y procedimientos dentro del objeto, ofreciendo una interface. Los objetos pueden estar distribuidos. Microservicios:\nMas info: https://microservices.io/ \u0026ldquo;same crap, but distributed\u0026rdquo; the biggest issue with microservices is that they convert nice errors with a stack trace to network errors SOA:\nLa aplicación es una composición de servicios. Estos pueden pertenecer a diferentes organizaciones administrativas. Ej: procesador de pagos. Basados en recursos:\nEn lugar de servicios, se consideran recursos. Popular por su simplicidad. Publish-subscribe # Separación de procesamiento y coordinación (comunicación y cooperación).\nEl sistema es visto como un conjunto de componentes autónomos.\nLograr que los componentes no tengan dependencias explicitas.\nLos componentes describen los eventos que le son de interés.\nEvent-based\nReferencialmente desacoplados Temporalmente acoplados Space-based\nReferencial y temporalmente desacoplados. Comunicación mediante tuplas Procesos ingresan tuplas en un espacio compartido. Recuperación mediante búsqueda Ambos tipos se pueden combinar (generar evento cuando tuplas de interés son ingresadas al espacio de intercambio)\nEn este caso, hablamos de publicación - subscripción.\n- Se deben describir los eventos de interes. - Generalmente como (atributo, valor) o (atributo, rango) El middleware # Facilita el desarrollo de un sistema distribuido. Es una capa que administra recursos y ofrece servicios comunes.\nEl principal objetivo es ayudar en la transparencia de distribución.\nPor ejemplo, se puede encargar de:\nAcceso a recursos remotos. Ofrecer servicios para la comunicación entre componentes. Servicios de seguridad y administración. Recuperación de fallas. Coordinación. Etc. Algunos ejemplos concretos en sistemas distribuidos:\nServicio de Mensajería: RabbitMQ, ZeroMQ, Llamadas a procedimientos remotos: RPC, RMI, gRPC Objetos distribuidos: CORBA Streaming de datos y eventos: Apache Kafka Monitores de transacciones distribuidas El middleware se puede organizar de varias maneras. Por ejemplo:\nWrappers: por aplicación o centralizado. Interceptores: Permite ejecutar código adicional durante la ejecución de un servicio. Arquitectura del sistema # Ubicación e interaccion de los componentes software junto con el hardware.\nPensar en clientes que piden servicios a servidores ayuda con la complejidad de los sistemas distribuidos.\nArquitectura en capas # Cliente-servidor:\nModelo más sencillo Procesos divididos en dos grupos: clientes que invocan un servicio implementado en servidores La invocacion puede usar una conexión no confiable (quiza usando operaciones idempotentes) o confiable (TCP, cuando la red no es fiable). No siempre se puede definir de manera precisa la separación entre cliente y servidor. Puede variar. Existen múltiples alternativas de como distribuir tres capas lógicas en un modelo cliente-servidor.\nDos capas (two-tier) Multicapa: distribuir las capas en múltiples máquinas, por ejemplo una arquitectura de 3-capas. Distribución vertical: componentes lógicos separados en máquinas separadas.\nArquitecturas simétricas # Distribución horizontal: dividir cada componente lógico (servidor, cliente).\npeer to peer (p2p): las funcionalidades del sistema están presentes en todos los procesos que constituyen el sistema. Un nodo puede actuar tanto como cliente o como servidor. La arquitectura del sistema toma la forma de una red sobrepuesta, que puede ser estructurada o no.\np2p estructurados # Los nodos se organizan según alguna topología concreta: anillo, árbol, matriz, etc. En general cada nodo es responsable de mantener un cierto conjunto de datos, identificados mediante un identificador (generalmente, una función hash de los datos). Así, la red p2p es básicamente un tabla hash distribuida. La topología define como debe realizarse el ruteo de una consulta al nodo correspondiente.\nEjemplo: chord\np2p no estructurados # No existe una topología predefinida y cada nodo mantiene una lista ad-hoc de nodos vecinos, lo que da como resultado un grafo aleatorio. Al momento de unirse, un nodo contacta un nodo bien conocido para obtener una lista inicial de vecinos. La búsqueda de datos requiere técnicas como inundación o random walks.\nInundación: se pasa la búsqueda a todos los nodos vecinos. Un nodo ignora una búsqueda que ya recibió. Puede responder al nodo que originó la búsqueda o al que se la reenvió. La búsqueda tiene un TTL asociado. TTL igual a 1 para buscar entre nodos vecinos.\nAleatorio: se pregunto a un nodo vecino al azar. Si no tiene el dato, este repite el procedimiento. Menor trafico, mayor tiempo de búsqueda. Se puede paralelizar y también tiene un TTL asociado.\nPor política: mantener una lista de nodos que han respondido peticiones, etc.\np2p jerárquicos # Para aliviar problemas de escalabilidad, un p2p no-estructurado puede tener nodos especiales que mantengan un índice de items o datos, conocidos como \u0026ldquo;super pares\u0026rdquo;.\nNodo \u0026ldquo;weak\u0026rdquo; se conecta a la red a travez de un super-par. Puede ser siempre el mismo o no. Para mejorar confiabilidad, puede requerirse conectarse a n \u0026gt; 1 superpares. Los nodos superpares se organizan en una red p2p propia (de ahí la jerarquía) Problemas: ¿Cómo elegir que nodo superpar utilizar? ¿Cómo elegir cuales seran superpares? Elección de lider. Ejemplo: bittorrent, CDN.\nArquitecturas híbridas # En la práctica, un sistema complejo abarca múltiples arquitecturas.\nCloud computing # Permite el acceso a un conjunto de recursos virtualizados de fácil acceso. Cúantos de estos recursos son necesarios y cómo serán usados, es definido dinámicamente: por ejemplo, si un cliente requiere más poder de cómputo, simplemente puede pedir procesador virtuales adicionales. Básicamente, una nube se organiza en cuatro capas:\nHardware: la capa más baja, que los clientes generalmente no ven, organizada en data-centers. Infraestructura: una capa de virtualización sobre los recursos de hardware, para ofrecerlos a los clientes. Plataforma: provee una capa de abstracción para la ejecución de aplicaciones y/o administración de recursos como almacenamiento. Aplicación: aplicaciones que pueden ser adaptadas por los clientes, como suites ofimáticas. Estas capas son accesibles mediante una multitud de interfaces (web-services, APIs, etc).\nA su vez, da lugar a tres capas de servicios diferenciados:\nIasS (Infraestructure-as-a-service) PaaS (Platform-as-a-service) SaaS (Software-as-a-service) FaaS (Function-as-a-service): ejemplo AWS Lambda. El uso de un servicio en la nube tiene similitudes con la arquitectura cliente-servidor. Sin embargo, el servidor es totalmente opaco al cliente: no se sabe donde ejecuta, como esta implementado, etc.\nEdge computing # Como colocar los recursos en el \u0026ldquo;límite\u0026rdquo; de la red, entre los dispositivos y la nube. Generalmente, en los ISPs. Complementa cloud para reducir la latencia y el uso de ancho de banda. También permite aumentar la confiabilidad, y puede ser necesario para cumplir con políticas de privacidad y seguridad. Aumenta la complejidad de la administración de la aplicación.\nEj: Akamai, Netflix CDN, IoT, etc.\nArgumentos a favor de edge computing:\nLatencia y ancho de banda: aunque el ancho de banda se ha incrementado en los últimos años, contar con los recursos más cerca del usuario final permite mejores garantías acerca del ancho de banda negociado. En cambio, la latencia es un problemas más complicado y donde existe un límite físico. En este caso, la cercanía reduce la latencia.\nConfiabilidad: Existen ciertos casos donde se debe garantizar el funcionamiento aún ante falta de conectividad a la nube.\nSeguridad y privacidad: por razones politicas/regulatorias ciertos datos no pueden ser subidos a la nube.\nDesafios en orquestación:\nRecursos: para garantizar la disponibilidad de recursos, ¿como deben ser asignados o provisionados?\nUbicación: Dónde y cúando los recursos deben ser hechos disponibles.\nSelección: no necesariamente el nodo más cercano es el mejor.\nBlockchain apps # Una presunción en el diseño de estas aplicaciones es que ningún nodo es confiable. Las transacciones son registras por un gran número de nodos participantes. Entre todos los nodos se mantiene una sola cadena de transacciones validadas. Dado que cada bloque es inmutable, la estructura de datos es fácilmente replicable.\nLa diferencia fundamental entre múltiples implementaciones es cuales nodos se encargan de realizar las validaciones (esto es, agregar nuevos bloques a la cadena). Agregar un bloque es básicamente llegar a un consenso entre los distintos nodos con rol de validador. Los tipos de consenso pueden ser:\nCentralizado: posible, pero en contra del diseño del sistema.\nDistribuido: un grupo preseleccionado de nodos se encarga de este rol.\nLos nodos llegan a un consenso, tolerando así participantes maliciosos. Si hay n nodos validadores, se toleran hasta k \u0026lt;= (n - 1)/3 nodos maliciosos/defectuosos. El problema es que en general n es un numero pequeño. Descentralizada: todos los nodos participantes llegan a un consenso.\nMediante consenso todos los nodos escogen un nodo que llevara adelante la validación. Este validación puede ser premiada. No todos los nodos desearan ser elegibles, principalmente por costo de la validación. "},{"id":20,"href":"/posts/01-introduccion/","title":"Introducción a los Sistemas Distribuidos","section":"Posts","content":"the #1 rule of distribute computing: Don’t distribute your computing! At least if you can in any way avoid it\nYou\u0026rsquo;re not Google. Your company will never be Google\u0026hellip; Is there a reason we can\u0026rsquo;t just do this all in Postgres?\nAvances imporantes han ocurrido en las últimas décadas:\nDesarrollo de microprocesadores potentes, pequeños y ecónomicos. Avance de las tecnologías de comunicaciones. Miniaturización de los sistemas de cómputo (ES, IoT, SoCs, etc). En la actualidad es relativamente sencillo desarrollar un sistema compuesto de múltiples computadoras conectadas por una red. Al estar las computadoras físicamente separadas se habla de un sistema distribuido.\nDefinición # You know you have a distributed system when the crash of a computer you have never heard of stops you from getting any work done. \u0026ndash; Leslie Lamport\nUna colección de elementos computacionales autónomos que dan la apariencia a sus usuarios de ser un sistema coherente \u0026ndash; Tanenbaum y Van Steen.\nAunque no existe una definición que sea ampliamente aceptada por toda la disciplina, la distribución de los componentes en diferentes sistemas comunicados mediante una red es una característica común.\nCaracteristica 1: elementos independientes # Nodos independientes que colaboran para alcanzar un objetivo común. Los nodos son heterogéneos. La comunicación entre los nodos se realiza mediante paso de mensajes. No se existe un reloj global (dificulta la sincronización y coordinación). La concurrencia y el paralelismo es natural. Organizado como una red superpuesta, estructurada o no-estructurada (ej: sistemas p2p). Fallas parciales (independientes). Se tiene que resolver cuestiones de organización y membresía (grupos cerrados, abiertos). Caracteristica 2: sistema coherente # El sistema se comporta de acuerdo a las expectativas de sus usuarios. Transparencia de distribución: no importa como, cuando ni donde se conecte al sistema, el usuario debe tener el mismos servicio. Sin embargo, no es posible (ni deseable) ocultar todos los detalles de la distribución del sistema. Fundamental poder lidiar con fallas parciales. Distribuido vs Descentralizado # Conceptos relacionados\nSistema distribuido: componentes colaboran para realizar una tarea o proveer un servicio.\nSistema descentralizado: componentes con mayor autonomía sin único punto de control.\nUn sistema distribuido puede estar logicamente centralizado: DNS.\nUn sistema descentralizado no tiene una autoridad central: blockchain (ej. Bitcoin)\nOtra vision es la siguiente:\nSistema integrativo (conectar sistemas existentes formando así uno nuevo) Sistema expansivo (agregar nodos a un sistema existente). Luego:\nSistema descentralizado: visión integrativa, los recursos se encuentran necesariamente dispersos. Sistema distribuido: visión expansiva, los recursos se encuentran suficientemente dispersos. Complejidad # Los sistemas distribuidos son inherentemente complejos. Los sistemas centralizados son más sencillos. La distribución no es un fin en sí mismo: considerar soluciones lo más simples posibles. Middleware # Los componentes y funciones comunmente usados en un sistema distribuido se agrupan en un middleware, una capa de software entre el sistema operativo y las aplicaciones que intenta abstraer los detalles escabrosos y ofrecer una interfaz más amigable.\nPor ejemplo, un middleware ofrece:\nComunicación (RPC, RMI, paso de mensajes, etc.) Manejo de transacciones. Composición de servicios. Confiabilidad. Objetivos de diseño # Sólo por que sea posible no quiere decir que diseñar un sistema distribuido sea siempre una buena idea.\nUn sistema distribuido debe poder satisfacer alguno de los siguientes objetivos, para que su implementación valga la pena:\nPermitir que los recursos sean más fácilmente accesibles. Ocultar en lo posible que los recursos están desperdigados (transparencia de distribución). Debe ser abierto. Debe poder ser escalable. Compartir recursos # Por cuestiones económicas. Mejorar la colaboración. Ejemplo clásico: p2p Transparencia de distribución # Un sistema distribuido debe (en lo posible) ocultar que los procesos y recursos estan fisicamente distribuidos: esto se conoce como transparencia de distribución.\nDiversos tipos:\nAcceso: ocultar cómo se accede al recurso y la representación de datos. Ubicación: ocultar la ubicación de un recurso. Reubicación: ocultar el hecho de que el recurso pueda cambiar su ubicación mientras esta en uso. Migración: ocultar el hecho de que un recurso cambie su ubicación. Replicación: ocultar el hecho de que existan múltiples copias de un mismo recurso. Concurrencia: ocultar el hecho de que un recurso pueda ser accedido por múltiples usuarios. Falla: ocultar la falla y recuperación de un recurso u objeto. No siempre es deseable o posible alcanzar el máximo grado de transparencia.\nEs imposible ocultar las latencias de una red WAN u ocultar la falla de un nodo. Compromiso entre el nivel de transparencia y perfomance: Mantener las replicas consistentes incurre en un costo temporal que no se puede ocultar. Se puede argumentar que es mejor exponer la distribución al usuario, en lugar de ocultarla. Abierto # Poder interactuar con otros sistemas. Requiere interfaces bien definidas.\nUn sistema abierto es aquel que permite que sus componentes sean utilizados en otros sistemas. También generalmente un sistema abierto esta compuesto por componentes de otros sistemas. Beneficia la interoperabilidad, portabilidad, composibility y extensibilidad. Una característica importante para lograr este objetivo es la de separar política de mecanismo, evitando soluciones monolíticas.\nEscalabilidad # La escalabilidad abarca tres dimensiones:\nTamaño: la facilidad con que se pueden sumar usuarios o recursos.\nGeneralmente relacionado con limites en capacidad de cómputo, almacenamiento y ancho de banda. Pueden ser formalmente analizados mediante teoría de colas. Geografía: los recursos y usuarios pueden estar desperdigados pero las latencias no afectan seriamente al sistema.\nEl principal problema es la comunicación sincrónica sobre enlaces con alta latencia. Las WANs ofrecen menor confiabilidad que una LAN, menor capacidad de ancho de banda. ¿Multicast / Broadcast? Posible en LANs, no tan así en WANs. Administrativa: el sistema abarca distintas unidades organizacionales pero aún así es fácilmente administrable.\nCómo resolver conflictos de políticas acerca de uso, pago, administración, seguridad, etc. Ejemplos:\nTamaño: incrementar fácilmente el número de usuarios o procesos. Geografía: poder aumentar la distancia entre nodos. Administrativo: integrar recursos de otra organización. Soluciones:\nEscalar verticalmente: simplemente incrementar la capacidad del servicio (computo, almacenamiento o ancho de banda). Escalar horizontalmente: Ocultar latencias: comunicación asíncrona, fat-clients, etc. Distribuir el trabajo: dividir un componente y dispersarlo por el sistema. Ej: mover computo al cliente (Java Applet), descentralizar un servicio (DNS), descentralizar contenido (WWW), etc. Replicar: contar con una copia cercana, cache, etc. Problemas de consistencia. Consistencia estricta requiere sincronización global (costoso, reduce escalabilidad). Tipos de sistemas distribuidos # A grandes rasgos, podemos clasificar los sistemas distribuidos en sistemas distribuidos de cómputo, de información y pervasivos.\nCómputo: Cluster: conjunto de sistemas interconectados por una red de alta velocidad. Grid: nodos dispersos, heterogéneos, diferentes organizaciones. Cloud: software/infraestructura como servicio. Edge Información: Integración de sistemas de información ya existentes; ofrecer servicios como transacciones distribuidas. Pervasiva: Sistemas móviles, embebidos, IoT. No existe una topología estática, ni conexión permanente, etc. Tres tipos: ubicuos, móviles y redes de sensores (los límites entre la categorías son difusos). Falacias # Desarrollar un (buen) sistema distribuido es una tarea ardua. Las siguientes falsas presunciones durante el diseño del sistema, traen como consecuencia complejidad innecesaria y errores:\nLa red es confiable. La red es segura. La red es homogenea. La topología no cambia. La latencia es cero. El ancho de banda es infinito. El costo del transporte es cero. Sólo existe un administrador. Algunas más:\nUn sistema centralizado no escala: Un sistema físicamente centralizado quizá no, pero uno lógicamente centralizado sí (ejemplo DNS). Un sistema centralizado tiene un unico punto de falla: Si, pero un solo punto de falla es más fácil de administrar, más fácil de arreglar. Soluciones: en el caso de DNS, cada root server es a su vez un cluster. ¿Que vamos a estudiar? # Arquitectura: ¿Como organizar el sistema? Procesos: ¿Procesos, hilos? Comunicacion: ¿Como comunicar entre los nodos? Coordinación: ¿Cómo coordinar acciones? ¿Y cómo hacerlo de una manera independiente de la aplicación? Nombres: ¿Cómo identificar los diferentes recursos? Consistencia y replicación: Si se replica, ¿como se maneja la consistencia? Tolerancia a fallas: como mantener el sistema funcionando ante la falla de un componente. Seguridad: asegurar acceso autorizado a los recursos. "},{"id":21,"href":"/about/","title":"About","section":"","content":"Página de la materia Sistemas Distribuidos de la carrera Licenciatura en Informática de la Facultad de Ingeniería de la Universidad Nacional de la Patagonia San Juan Bosco, Sede Puerto Madryn.\n"}]